# 递归

## **递归基础理论**

**递归分为 "递" 和 ”归“ 两个过程，向下发展的 递进过程和 向上回来 回归过程**

同时满足以下**==三个条件==**，即可以用递归来求解问题

1.  **一个问题的解可以分解为几个子问题的解**
2.  **这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样**
3.  **存在递归终止条件**

> **写递归代码最关键的 是写出递推公式，找到终止条件，剩下将递推公式转化为代码就很简单了。**

经典的递归思维产生示例：（爬楼梯问题）

假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种 走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子 上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？

我们仔细想下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法

用公式表示就是： `f(n) = f(n-1)+f(n-2)`

> 这里从 第一步走法举例，发现第一步的走法的结果可以分为两个小问题，小问题是，已经走完第一步的情况下，接下来怎么走，依次向下推导，可以发现满足递归使用的条件（划分为小问题，数据规模一样，求解思路完全一样），推导出公式是非常关键的一部分，我们从第一步发现，求解第一步的的值，需要第一步中走了一步和走了两步的各自可能的数值之和，进而推导到 N 级问题，从而推导出递归公式

**推断递归终止条件 f(1)=1、f(2)=2 ，可以用较小的数来测试公式，也可能用较小的数来推导出终止条件**

推导出最终的递归代码：

```c
int f(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    return f(n-1) + f(n-2);
}
```

> **写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。**

## **递归最大的误区**

人脑几乎没办法把整个“递”和“归”的过程一步一步都想清 楚。比如上述爬楼梯问题，在推导出 递推公式 后，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。计算机擅长做重复的事情，所以递归正和它的胃口。而我们人脑更喜欢平铺直叙的思维方 式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然 后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去

**对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区**。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍

**如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解 决，在此基础上思考如何解决问题 A。而且，==你只需要思考问题 A 与子问题 B、C、D 两层 之间的关系==即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间 的关系。屏蔽掉递归细节，这样子理解起来就简单多了。**

> **编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一 层层的调用关系，不要试图用人脑去分解递归的每个步骤。**
>
> **在拿到递归题目时，直接编写 递归函数（找到子问题与母问题之间的关系），不要人肉的进行递归！！！**
>
> **要熟练掌握 数学归纳法 的思维**

## 递归代码要警惕堆栈溢出

堆栈溢出会造成系统性崩溃，后果会非常严重，如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。

**如何避免出现堆栈溢出**

我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定 深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。（但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有 关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性）

**递归方法适用于数据量很小的问题**

如果最 大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。

## 递归代码要警惕重复计算

递归代码中很可能会使用到一个数据多次重新计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。 当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回， 不需要重复计算，这样就能避免刚讲的问题了。

## **递归算法的效率**

**在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成 一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面讲到的 电影院递归代码，空间复杂度并不是 O(1)，而是 O(n)。本质时间复杂度很高**

> 递归是什么，递归就是用栈的数据结构，加上一个简单的逻辑算法实现了业务功能。

## 递归代码改写为非递归代码

爬楼梯问题改为 迭代循环 来解决

```c
int f(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;

    int ret = 0;
    int pre = 2;
    int prepre = 1;
    for (int i = 3; i <= n; ++i) {
        ret = pre + prepre;
        prepre = pre;
        pre = ret;
    }
    return ret;
}
```

**是不是所有的递归代码都可以改为这种==迭代循环==的非递归写法呢**？

笼统地讲，是的。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟 机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈 过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。 **但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度**。

> 也就是说 使用 迭代循环 其实本质也是一种 **“递归”** 在效率上并没有提高，换汤不换药

## 递归代码模板（解题方法）

**递归代码的基本形式**

```JS
// JavaScript
const recursion = (level, params) =>{
    
   // recursion terminator  递归终结条件
   if(level > MAX_LEVEL){
     process_result
     return 
   }
    
   // process current level	处理当前层逻辑
   process(level, params)
    
   //drill down	下探到下一层
   recursion(level+1, params)
    
   //clean current level status if needed  清理当前层
}
```

关于递归算法的解题方法，我们还是回到递归的三个重要条件上

> 同时满足以下**==三个条件==**，即可以用递归来求解问题
>
> 1.  **一个问题的解可以分解为几个子问题的解**
> 2.  **这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样**
> 3.  **存在递归终止条件**

==**递归题目的难点就在与 如何发现 子问题与父问题之间的关系，找到规律，并且把抽象的问题转化为 用公式来表示，这十分看重对 数学归纳法 的掌握**==

方法一，尝试从小的测试数据来找到 其中的规律，（但是不要过多的人肉递归！！）







