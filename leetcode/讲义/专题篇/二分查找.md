# 二分查找

二分查找又称`折半搜索算法`。 狭义地来讲，二分查找是一种在有序数组查找某一特定元素的搜索算法。

## 常见分类

给定一个由数字组成的有序数组 nums，并给你一个数字 target。问 nums 中是否存在 target。如果存在， 则返回其在 nums 中的索引。如果不存在，则返回 - 1。

这是二分查找中最简单的一种形式。当然二分查找也有很多的变形，这也是二分查找容易出错，难以掌握的原因。

常见变体有：

- **如果存在多个满足条件的元素，返回最左边满足条件的索引。**
- **如果存在多个满足条件的元素，返回最右边满足条件的索引。**
- **数组不是整体有序的。 比如先升序再降序，或者先降序再升序。**
- **将一维数组变成二维数组。**

## 前提

- **数组必须是有序的**（如果无序，我们也可以考虑排序，不过要注意排序的复杂度）

## 术语

二分查找中使用的术语：

- target —— 要查找的值
- index —— 当前位置
- l 和 r —— 左右指针
- mid —— 左右指针的中点，用来确定我们应该向左查找还是向右查找的索引

## 常见题型

### 查找一个数

算法描述：

- 先从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；
- 如果目标元素大于中间元素，则在数组大于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。
- 如果目标元素小于中间元素，则在数组小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。
- 如果在某一步骤数组为空，则代表找不到。

**复杂度分析**

- 平均时间复杂度： $$O(logN)$$
- 最坏时间复杂度： $$O(logN)$$
- 最优时间复杂度： $$O(1)$$
- 空间复杂度
  - 迭代: $$O(1)$$
  - 递归： $$O(logN)$$（无尾调用消除）

这种搜索算法每一次比较都使搜索范围缩小一半，是典型的二分查找。

这个是二分查找中最简答的一种类型了，我们先来搞定它。 我们来一个具体的例子， 这样方便大家增加代入感。假设 nums 为 `[1,3,4,6,7,8,10,13,14]`， target 为 4·。

- 刚开始数组中间的元素为 7
- 7 > 4 ，由于 7 右边的数字都大于 7 ，因此不可能是答案。我们将范围缩写到了 7 的左侧。
- 此时中间元素为 3
- 3 < 4，由于 3 左边的数字都小于 3 ，因此不可能是答案。我们将范围缩写到了 3 的右侧。
- 此时中间元素为 4，正好是我们要找的，返回其索引 2 即可

#### 思维框架

首先定义搜索区间为 [left, right]，注意是左右都闭合

- 由于定义的搜索区间为 [left, right]，因此当 left <= right 的时候，搜索区间都不为空，此时我们都需要继续搜索。 也就是说终止搜索条件应该为 left <= right。

> 举个例子容易明白一点。 比如对于区间 [4,4]，其包含了一个元素 4，因此搜索区间不为空，需要继续搜索（试想 4 恰好是我们要找的 target，如果不继续搜索， 会错过正确答案）。而当搜索区间为 [left, right) 的时候，同样对于 [4,4]，这个时候搜索区间却是空的，因为这样的一个区间不存在任何数字·。

- 循环体内，我们不断计算 mid ，并将 nums[mid] 与 目标值比对。
  - 如果 nums[mid] 等于目标值， 则提前返回 mid（只需要找到一个满足条件的即可）
  - 如果 nums[mid] 小于目标值， 说明目标值在 mid 右侧，这个时候搜索区间可缩小为 [mid + 1, right] （mid 以及 mid 左侧的数字被我们排除在外）
  - 如果 nums[mid] 大于目标值， 说明目标值在 mid 左侧，这个时候搜索区间可缩小为 [left, mid - 1] （mid 以及 mid 右侧的数字被我们排除在外）
- 循环结束都没有找到，则说明找不到，返回 -1 表示未找到。

#### 代码模版

***JavaScript***

```JS
function binarySearch(nums, target) {
  let left = 0;
  let right = nums.length - 1;
  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);
    if (nums[mid] == target) return mid;
    if (nums[mid] < target)
      // 搜索区间变为 [mid+1, right]
      left = mid + 1;
    if (nums[mid] > target)
      // 搜索区间变为 [left, mid - 1]
      right = mid - 1;
  }
  return -1;
}
```

***Java***

```Java
public int binarySearch(int[] nums, int target) {
    // 左右都闭合的区间 [l, r]
    int left = 0;
    int right = nums.length - 1;

    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] == target)
            return mid;
        if (nums[mid] < target)
			      // 搜索区间变为 [mid+1, right]
            left = mid + 1;
        if (nums[mid] > target)
            // 搜索区间变为 [left, mid - 1]
            right = mid - 1;
    }
    return -1;
}
```

#### 推荐题目

- [x] [69.x的平方根](/leetcode/题目/专题篇/二分查找/69.x的平方根.md)

### 寻找最左边的满足条件的值

和`查找一个数`类似， 我们仍然套用`查找一个数`的思维框架和代码模板。

#### 思维框架

- 首先定义搜索区间为 [left, right]，注意是左右都闭合
- 终止搜索条件为 left <= right。
- 循环体内，我们不断计算 mid ，并将 nums[mid] 与 目标值比对。
  - 如果 nums[mid] 等于目标值， **则收缩右边界，我们找到了一个备胎，继续看看左边还有没有了**（**注意这里不一样**）
  - 如果 nums[mid] 小于目标值， 说明目标值在 mid 右侧，这个时候搜索区间可缩小为 [mid + 1, right]
  - 如果 nums[mid] 大于目标值， 说明目标值在 mid 左侧，这个时候搜索区间可缩小为 [left, mid - 1]
- 由于不会提前返回，因此我们需要检查最终的 left，看 nums[left]是否等于 target。
  - 如果不等于 target，或者 left 出了右边边界了，说明至死都没有找到一个备胎，则返回 -1.
  - 否则返回 left 即可，备胎转正。

#### 代码模板

> 实际上 nums[mid] > target 和 nums[mid] == target 是可以合并的。这里为了清晰，就没有合并，

***Java***

```java
public int binarySearchLeft(int[] nums, int target) {
	// 搜索区间为 [left, right]
    int left = 0;
    int right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            // 搜索区间变为 [mid+1, right]
            left = mid + 1;
        }
        if (nums[mid] > target) {
            // 搜索区间变为 [left, mid-1]
            right = mid - 1;
        }
        if (nums[mid] == target) {
            // 收缩右边界
            right = mid - 1;
        }
    }
    // 检查是否越界
    if (left >= nums.length || nums[left] != target)
        return -1;
    return left;
}
```

javascrpit

```javascript
function binarySearchLeft(nums, target) {
  let left = 0;
  let right = nums.length - 1;
  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);
    if (nums[mid] == target)
      // 收缩右边界
      right = mid - 1;
    if (nums[mid] < target)
      // 搜索区间变为 [mid+1, right]
      left = mid + 1;
    if (nums[mid] > target)
      // 搜索区间变为 [left, mid - 1]
      right = mid - 1;
  }
  // 检查是否越界
  if (left >= nums.length || nums[left] != target) return -1;
  return left;
}
```

**最后的 检查是否越界 意义**

寻找最左边的满足条件的值等题型，如果最后 left >= nums.length 说明一直是 left 在收缩，最大值也不等于目标值，那么也就是没有满足条件的值，更别说满足条件的最小值。

**为什么这里 如果有满足条件的值，一定会 存在  nums[left] = target？**

这边满足条件的值都收缩掉了，继续寻找，如果两个不连在一起且满足条件的值，那么返回掉前面的那个较小值，如果那个值之后没有其他满足条件的值，那么一定会始终是收缩 left （因为数组是有序的），直到 left = right ,而此时还是 left 过小，所以继续收缩 left ，left = mid + 1 ，即 left 为 right 右侧的那个值 ，也就是之前的备胎，如果 right右侧的值不为 target， 说明数组内不存在这样的值，备胎都没有

#### 推荐题目

- [x] [278.第一个错误版本](/leetcode/题目/专题篇/二分查找/278.第一个错误版本.md)

### 寻找最右边的满足条件的值

和`查找一个数`类似， 我们仍然套用`查找一个数`的思维框架和代码模板。

> 有没有感受到框架和模板的力量？

#### 思维框架

- 首先定义搜索区间为 [left, right]，注意是左右都闭合

- 终止搜索条件为 left <= right。
- 循环体内，我们不断计算 mid ，并将 nums[mid] 与 目标值比对。
  - 如果 nums[mid] 等于目标值， **则收缩左边界，我们找到了一个备胎，继续看看右边还有没有了**
  - 如果 nums[mid] 小于目标值， 说明目标值在 mid 右侧，这个时候搜索区间可缩小为 [mid + 1, right]
  - 如果 nums[mid] 大于目标值， 说明目标值在 mid 左侧，这个时候搜索区间可缩小为 [left, mid - 1]
- 由于不会提前返回，因此我们需要检查最终的 right，看 nums[right]是否等于 target。
  - 如果不等于 target，或者 right 出了左边边界了，说明至死都没有找到一个备胎，则返回 -1.
  - 否则返回 right 即可，备胎转正。

#### 代码模版

***JavaScript***

```JS
function binarySearchRight(nums, target) {
  let left = 0;
  let right = nums.length - 1;
  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);
    if (nums[mid] == target)
      // 收缩左边界
      left = mid + 1;
    if (nums[mid] < target)
      // 搜索区间变为 [mid+1, right]
      left = mid + 1;
    if (nums[mid] > target)
      // 搜索区间变为 [left, mid - 1]
      right = mid - 1;
  }
  // 检查是否越界
  if (right < 0 || nums[right] != target) return -1;
  return right;
}
```

**最后的 检查是否越界 意义**

寻找最右边的满足条件的值等题型，如果最后 right < 0 说明一直是 right 在收缩，最小值也不等于目标值，那么也就是没有满足条件的值，更别说满足条件的最大值。

**为什么这里 如果有满足条件的值，一定会 存在  nums[right] = target？**

这边满足条件的值都收缩掉了，继续寻找，如果两个不连在一起且满足条件的值，那么返回掉后面的那个较大值，如果那个值之后没有其他满足条件的值，那么一定会始终是收缩 right （因为数组是有序的），直到 right = left ,而此时还是 right 过大，所以继续收缩 right ，right = mid - 1 ，即 right 为 left 左侧的那个值 ，也就是之前的备胎，如果left左侧的值不为 target， 说明数组内不存在这样的值，备胎都没有

## 

## 寻找最左插入位置，寻找最右插入位置？？

### 局部有序（先降后升或先升后降）

**例题**

- [x] [33.搜索旋转排序数组](/leetcode/题目/专题篇/二分查找/33.搜索旋转排序数组.md)
- [x] [81.搜索旋转排序数组二](/leetcode/题目/专题篇/二分查找/81.搜索旋转排序数组二.md)

结合寻找最左边的满足条件的值 

- [ ] [面试题10.03.搜索旋转数组](/leetcode/题目/专题篇/二分查找/面试题10.03.搜索旋转数组.md)

