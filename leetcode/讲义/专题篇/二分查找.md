

# 二分查找

二分查找又称`折半搜索算法`。 狭义地来讲，**二分查找是一种在有序数组查找某一特定元素的搜索算法。**

## 常见分类

给定一个由数字组成的有序数组 nums，并给你一个数字 target。问 nums 中是否存在 target。如果存在， 则返回其在 nums 中的索引。如果不存在，则返回 - 1。

这是二分查找中最简单的一种形式。当然二分查找也有很多的变形，这也是二分查找容易出错，难以掌握的原因。

常见变体有：

- **如果存在多个满足条件的元素，返回最左边满足条件的索引。**
- **如果存在多个满足条件的元素，返回最右边满足条件的索引。**
- **数组不是整体有序的。 比如先升序再降序，或者先降序再升序。**
- **将一维数组变成二维数组。**

## 前提

- **数组必须是有序的**（如果无序，我们也可以考虑排序，不过要注意排序的复杂度）

## 术语

二分查找中使用的术语：

- target —— 要查找的值
- index —— 当前位置
- l 和 r —— 左右指针
- mid —— 左右指针的中点，用来确定我们应该向左查找还是向右查找的索引

## 常见题型

### 查找一个数

算法描述：

- 先从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；
- 如果目标元素大于中间元素，则在数组大于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。
- 如果目标元素小于中间元素，则在数组小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。
- 如果在某一步骤数组为空，则代表找不到。

**复杂度分析**

- 平均时间复杂度： $$O(logN)$$
- 最坏时间复杂度： $$O(logN)$$
- 最优时间复杂度： $$O(1)$$
- 空间复杂度
  - 迭代: $$O(1)$$
  - 递归： $$O(logN)$$（无尾调用消除）

这种搜索算法每一次比较都使搜索范围缩小一半，是典型的二分查找。

这个是二分查找中最简答的一种类型了，我们先来搞定它。 我们来一个具体的例子， 这样方便大家增加代入感。假设 nums 为 `[1,3,4,6,7,8,10,13,14]`， target 为 4·。

- 刚开始数组中间的元素为 7
- 7 > 4 ，由于 7 右边的数字都大于 7 ，因此不可能是答案。我们将范围缩写到了 7 的左侧。
- 此时中间元素为 3
- 3 < 4，由于 3 左边的数字都小于 3 ，因此不可能是答案。我们将范围缩写到了 3 的右侧。
- 此时中间元素为 4，正好是我们要找的，返回其索引 2 即可

#### 思维框架

首先定义搜索区间为 [left, right]，注意是左右都闭合

- 由于定义的搜索区间为 [left, right]，因此当 left <= right 的时候，搜索区间都不为空，此时我们都需要继续搜索。 也就是说终止搜索条件应该为 left <= right。

> 举个例子容易明白一点。 比如对于区间 [4,4]，其包含了一个元素 4，因此搜索区间不为空，需要继续搜索（试想 4 恰好是我们要找的 target，如果不继续搜索， 会错过正确答案）。而当搜索区间为 [left, right) 的时候，同样对于 [4,4]，这个时候搜索区间却是空的，因为这样的一个区间不存在任何数字·。

- 循环体内，我们不断计算 mid ，并将 nums[mid] 与 目标值比对。
  - 如果 nums[mid] 等于目标值， 则提前返回 mid（只需要找到一个满足条件的即可）
  - 如果 nums[mid] 小于目标值， 说明目标值在 mid 右侧，这个时候搜索区间可缩小为 [mid + 1, right] （mid 以及 mid 左侧的数字被我们排除在外）
  - 如果 nums[mid] 大于目标值， 说明目标值在 mid 左侧，这个时候搜索区间可缩小为 [left, mid - 1] （mid 以及 mid 右侧的数字被我们排除在外）
- 循环结束都没有找到，则说明找不到，返回 -1 表示未找到。

#### 代码模版

***JavaScript***

```JS
function binarySearch(nums, target) {
  let left = 0;
  let right = nums.length - 1;
  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);
    if (nums[mid] == target) return mid;
    if (nums[mid] < target)
      // 搜索区间变为 [mid+1, right]
      left = mid + 1;
    if (nums[mid] > target)
      // 搜索区间变为 [left, mid - 1]
      right = mid - 1;
  }
  return -1;
}
```

#### 推荐题目

- [x] [35.搜索插入位置](/leetcode/题目/专题篇/二分查找/35.搜索插入位置.md)

### 寻找最左边的满足条件的值

和`查找一个数`类似， 我们仍然套用`查找一个数`的思维框架和代码模板。

#### 思维框架

- 首先定义搜索区间为 [left, right]，注意是左右都闭合
- 终止搜索条件为 left <= right。
- 循环体内，我们不断计算 mid ，并将 nums[mid] 与 目标值比对。
  - 如果 nums[mid] 等于目标值， **则收缩右边界，我们找到了一个备胎，继续看看左边还有没有了**（**注意这里不一样**）
  - 如果 nums[mid] 小于目标值， 说明目标值在 mid 右侧，这个时候搜索区间可缩小为 [mid + 1, right]
  - 如果 nums[mid] 大于目标值， 说明目标值在 mid 左侧，这个时候搜索区间可缩小为 [left, mid - 1]
- 由于不会提前返回，因此我们需要检查最终的 left，看 nums[left]是否等于 target。
  - 如果不等于 target，或者 left 出了右边边界了，说明至死都没有找到一个备胎，则返回 -1.
  - 否则返回 left 即可，备胎转正。

#### 代码模板

> 实际上 nums[mid] > target 和 nums[mid] == target 是可以合并的。这里为了清晰，就没有合并，

***javascrpit***

```javascript
function binarySearchLeft(nums, target) {
  let left = 0;
  let right = nums.length - 1;
  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);
    if (nums[mid] == target)
      // 收缩右边界
      right = mid - 1;
    if (nums[mid] < target)
      // 搜索区间变为 [mid+1, right]
      left = mid + 1;
    if (nums[mid] > target)
      // 搜索区间变为 [left, mid - 1]
      right = mid - 1;
  }
  // 检查是否越界
  if (left >= nums.length || nums[left] != target) return -1;
  return left;
}
```

**最后的 检查是否越界 意义**

寻找最左边的满足条件的值等题型，如果最后 left >= nums.length 说明一直是 left 在收缩，最大值也不等于目标值，那么也就是没有满足条件的值，更别说满足条件的最小值。

**为什么这里 如果有满足条件的值，一定会 存在  nums[left] = target？**

这边满足条件的值都收缩掉了，继续寻找，如果两个不连在一起且满足条件的值，那么返回掉前面的那个较小值，如果那个值之后没有其他满足条件的值，那么一定会始终是收缩 left （因为数组是有序的），直到 left = right ,而此时还是 left 过小，所以继续收缩 left ，left = mid + 1 ，即 left 为 right 右侧的那个值 ，也就是之前的备胎，如果 right右侧的值不为 target， 说明数组内不存在这样的值，备胎都没有

#### 推荐题目

- [x] [278.第一个错误版本](/leetcode/题目/专题篇/二分查找/278.第一个错误版本.md)

  因为没有终止条件，所以最终两个指针一定会指向同一个元素，然后执行最后一次比较移动，如果是符合条件的元素，右指针左移动，此时 left 没移动，就是符合最左边的那个元素，如果这个元素不是符合条件的元素，那么 left 就会右移动，也是返回 left，因为right没移动，指向的那个元素并不是答案，所以把希望寄托在他的右边这个值，如果之前他是符合条件而使right  = mid - 1 的话，也就是备胎，返回这个值，他就是最左的那个值，所以要对这个值进行验证，这个值符不符合条件，符合是备胎，不是说明 right 是因为 nums[mid] > target 而移动到这里的。针对 278 这题因为一定会存在错误版本，所以可以不进行验证。

- [x] [35.搜索插入位置](/leetcode/题目/专题篇/二分查找/35.搜索插入位置.md)

### 寻找最右边的满足条件的值

和`查找一个数`类似， 我们仍然套用`查找一个数`的思维框架和代码模板。

#### 思维框架

- 首先定义搜索区间为 [left, right]，注意是左右都闭合

- 终止搜索条件为 left <= right。
- 循环体内，我们不断计算 mid ，并将 nums[mid] 与 目标值比对。
  - 如果 nums[mid] 等于目标值， **则收缩左边界，我们找到了一个备胎，继续看看右边还有没有了**
  - 如果 nums[mid] 小于目标值， 说明目标值在 mid 右侧，这个时候搜索区间可缩小为 [mid + 1, right]
  - 如果 nums[mid] 大于目标值， 说明目标值在 mid 左侧，这个时候搜索区间可缩小为 [left, mid - 1]
- 由于不会提前返回，因此我们需要检查最终的 right，看 nums[right]是否等于 target。
  - 如果不等于 target，或者 right 出了左边边界了，说明至死都没有找到一个备胎，则返回 -1.
  - 否则返回 right 即可，备胎转正。

#### 代码模版

***JavaScript***

```JS
function binarySearchRight(nums, target) {
  let left = 0;
  let right = nums.length - 1;
  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);
    if (nums[mid] == target)
      // 收缩左边界
      left = mid + 1;
    if (nums[mid] < target)
      // 搜索区间变为 [mid+1, right]
      left = mid + 1;
    if (nums[mid] > target)
      // 搜索区间变为 [left, mid - 1]
      right = mid - 1;
  }
  // 检查是否越界
  if (right < 0 || nums[right] != target) return -1;
  return right;
}
```

**最后的 检查是否越界 意义**

寻找最右边的满足条件的值等题型，如果最后 right < 0 说明一直是 right 在收缩，最小值也不等于目标值，那么也就是没有满足条件的值，更别说满足条件的最大值。

**为什么这里 如果有满足条件的值，一定会 存在  nums[right] = target？**

这边满足条件的值都收缩掉了，继续寻找，如果两个不连在一起且满足条件的值，那么返回掉后面的那个较大值，如果那个值之后没有其他满足条件的值，那么一定会始终是收缩 right （因为数组是有序的），直到 right = left ,而此时还是 right 过大，所以继续收缩 right ，right = mid - 1 ，即 right 为 left 左侧的那个值 ，也就是之前的备胎，如果left左侧的值不为 target， 说明数组内不存在这样的值，备胎都没有

#### 推荐题目

- [x] [69.x的平方根](/leetcode/题目/专题篇/二分查找/69.x的平方根.md)

### 寻找最左插入位置

比如一个数组 nums: [1,3,4]，target 是 2。我们应该将其插入（注意不是真的插入）的位置是索引 1 的位置，即 [1,**2**,3,4]。因此`寻找最左插入位置`应该返回 1，而`寻找最左满足条件` 应该返回-1。

另外如果有多个满足条件的值，我们返回最左侧的。 比如一个数组 nums: [1,2,2,2,3,4]，target 是 2，我们应该插入的位置是 1。

#### 思维框架

如果你将**寻找最左插入位置**看成是**寻找最左满足**大于等于 x 的值，那就可以和前面的知识产生联系，使得代码更加统一。唯一的区别点在于**前面是最左满足等于 x**，这里是**最左满足大于等于 x**。

具体算法：

- 首先定义搜索区间为 [left, right]，注意是左右都闭合，之后会用到这个点。

> 你可以定义别的搜索区间形式，不过后面的代码也相应要调整，感兴趣的可以试试别的搜索区间。

- 由于我们定义的搜索区间为 [left, right]，因此当 left <= right 的时候，搜索区间都不为空。 也就是说我们的终止搜索条件为 left <= right。
- 当 A[mid] >= x，说明找到一个备胎，我们令 r = mid - 1 将 mid 从搜索区间排除，继续看看有没有更好的备胎。
- 当 A[mid] < x，说明 mid 根本就不是答案，直接更新 l = mid + 1，从而将 mid 从搜索区间排除。
- 最后搜索区间的 l 就是最好的备胎，备胎转正。

#### 推荐题目

- [x] [35.搜索插入位置](/leetcode/题目/专题篇/二分查找/35.搜索插入位置.md)

### 寻找最右插入位置

### 局部有序

**（先降后升或先升后降）**

**例题**

- [x] [33.搜索旋转排序数组](/leetcode/题目/专题篇/二分查找/33.搜索旋转排序数组.md)
- [x] [81.搜索旋转排序数组二](/leetcode/题目/专题篇/二分查找/81.搜索旋转排序数组二.md)

*结合寻找最左边的满足条件的值* 

- [x] [面试题10.03.搜索旋转数组](/leetcode/题目/专题篇/二分查找/面试题10.03.搜索旋转数组.md)

### 二维数组

- [x] [74.搜索二维矩阵](/leetcode/题目/专题篇/二分查找/74.搜索二维矩阵.md)

### 寻找最值

- [ ] [153.寻找旋转排序数组中的最小值](/leetcode/题目/专题篇/二分查找/153.寻找旋转排序数组中的最小值.md)

## 题目推荐

- [875. 爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas/)
- [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/description/)
- [354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)
- [面试题 17.08. 马戏团人塔](https://leetcode-cn.com/problems/circus-tower-lcci/)

> 后面三个题建议一起做

**二分查找与其他结合的综合性题目**

- [x] [778.水位上升的泳池中游泳](/leetcode/题目/专题篇/二分查找/778.水位上升的泳池中游泳.md)

未完成的每日一题

- 4
- 1712

