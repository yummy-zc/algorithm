# 贪心算法

## 总结

关于贪心算法的解法

贪心算法的一个特点就是，这种解法不一定会找出整体最优的解法，但是在满足一定条件时局部最优解也就转变为整体最优解

首先在拿到问题后，我们把这个问题划分为一个一个的小问题，把每个问题都看作一个选项，个人认为贪心算法在求解整体最优解时关键在于各个选项的独立性，即顺序是否可以调换，比如背包问题中，先选择哪个物品都是没有影响的，比如报告厅使用问题，哪个学院先使用都是可以的，也就是给了你所有选项，你自己自由分配，那么我就可以按照某个标准，单位质量的价值，先结束的时间，（实际按照这个标准就是贪心的局部最优选择）来对各个选项进行排序（常用的实现方法），将最优的放在最前面，那么依次选择下来，实现了局部最优，同时也实现了整体最优

贪心算法从一个初始的空解出发，采用逐步构造最优解的方法向给定的目标前进，每一步决策都会产生n个元组，每一步贪心选择都会将所求的问题简化为规模更小的问题，并期望每次局部最优而产生全局最优，而背包问题就是把这个贪心选择标准选定为单位质量的价值，并且排序好了，那么在做贪心选择的时候可以直接选择局部最优解，同时也就照就了整体最优解

贪心与递归也存在不同，推进的每一步不是依据某一固定的递归式，而是做下一个看似最爱的贪心选择，不断的将问题实例归纳为更小的相似子问题（所以在使用贪心算法的时候一般没有使用递归来实现，通常都是提前已经将局部最优解排序好了，遍历选择即可）。

贪心与动态规划的区别就在与，贪心仅在与当前状态作出最好选择，然后再基于这个选择继续解决选择后产生的相应的子问题。（也就是贪心就是一条路走到黑，不会回溯，关键在与选择出局部最优解），背包问题也是如此，选择出单位价值最高的那个物品，剩余 c - Wmax 空间，剩余 n -1 个物品，接下来求解这一问题，也是类似于父问题一样，求解此状况下的最大价值背包，报告厅安排时间也是如此。

贪心算法在哈夫曼树中的应用，因为字符频率的特点，用尽可能小的编码来表示最常使用的字符，通过构建一个哈夫曼树最好，即离根节点越近越好（规定左边选择为0，右边选择为1，到达对应节点的路径即为其编码），那么相应的频率低的就离根节点就远一点，那么问题是如何构造一颗树呢（其实想到这个办法来解决字符用编码表示的问题已经很牛逼了....），采用就是贪心算法，从一堆节点中，选择出频率最低的两个节点，合并成一颗小树，节点值也合并，再放回到原来的一堆节点，把他自己又看作一个节点，权值（频率）相加，继续选择出最小权值的两个节点，直到合并成一颗树，哈夫曼树也就构成了，然后通过遍历树，分别求出每个字符的编码表示值。

### 背包问题

一个书包最多承重w千克物品，现在有各种类型的糖，价格和重量各不一样，现在选择出在不超过承重质量的情况下，选择出承载价值最大的背包。根据贪心算法的定义，实现局部最优，那么这题可以先将糖果按单位质量价值最高的排序分类好，那么**局部最优**，多阶段选择最优来解决，将单位价值高的依次装入书包中，直到装满

### 报告厅时间安排/区间不相交问题

各学院在一天内都要使用一个报告厅，每个学院使用的时间段和时长都不相同，如何安排来实现使最多的学院都用到报告厅呢。

将区间按照结束时间排序，依次选择最早结束的学院来安排，但是保证后面一个学院开始的时间不能超过前面一个学院结束的时间，从而解决了问题

**每次选择都让剩余的时间尽可能的大**，那么后面可安排选择也就越多，这就是一种贪心算法的典型实践，保证每次的选择是最优的，从局部最优来实现整体最优（注意是选择出最优的一种情况，并不是唯一的最优，因为可能还有学院时间段相近，在阶段选择的时候都满足条件）

> 难点就在与如何寻找到这个标准，以什么样的标准来进行贪心（比如说这里的结束时间作为贪心变量，和背包问题中的单位质量价值最高来作为贪心变量，通常都是选择出贪心变量然后将其排序，在满足一些小的限制情况下，来依次选择）

### 哈夫曼编码

> [图解哈夫曼编码](https://segmentfault.com/a/1190000021548305)

通常的编码方式有固定长度编码和不定长度编码两种。哈夫曼编码是不定长度编码的一种，它利用字符的使用频率来编码，经常使用的字符编码较短，不常使用的字符编码较长。目的是为了总的编码长度最短，空间效率最高，

比如说某个文件由 a 、b、c、d、e、f 六种字符组成，如果采用 固定长度的编码方式，设置001 为 a ,010 为 b ...（三位有八种编码，这里取六种），那么如果一共有1000个字符组成，那么 就需要 8000个bits，也就是1000个字节存储，但是我们如果使用 不定长度编码来表示的话，那么就可以节约空间来实现压缩，同时搭配频率高低数量位的编码方式来表示字符（编码尽可能的短），同时还得实现不能有二义性

**编码尽可能的短**：比如 a 字符出现频率最高，那么我们选择 表示 a 的字符编码为 1 ，b 字符出现频率其次，我们选择其 字符编码为 01 ，出现频率最低的 则表示一个字符所占用的位数较多

**不能有二义性**：任何一个字符的编码不能是另一个字符的前缀，即前缀码特性,例如不能有“10”和“101”这样的编码。**而如何是实现选择各个字符使用什么样的编码是关键的一步，这里我们就要用到贪心算法了**

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20201015093748979.png)

**应用贪心算法**：构建哈夫曼树，具体过程可以参考上面的引用链接

哈夫曼编码的基本思想是以字符的使用频率作为权值构建一颗哈夫曼树，然后利用哈夫曼树对字符进行编码。构造一棵哈夫曼树，是将要编码的字符作为叶子节点，该字符在文件中的使用频率作为叶子节点的权值，以自底向上的方式，通过n-1次的“合并”运算后构造出一棵树。

贪心策略是每次从树的集合中**取出没有父节点且权值最小的两棵树作为左右子树，构造一棵新树，新树根节点的权值为其左右孩子节点权值之和，将新树插入到树的集合中，继续使用贪心策略进行选择，直到树的集合中只剩一棵树时结束。**

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20201015094442014.png)

> 合并的节点只是工具节点，叶子节点才是要表示的节点，
>
> 使用树这种结构，各节点选择（不使用工具节点只用叶子节点表示字符 ），十分适用于这种哈夫曼编码的特性，也就是无二义性，左右选择一方向后各个后面的衍生的都具有唯一性且前缀不相同

### 多向图选择最短路径（不适用贪心）

这种类型明显暴露了贪心法存在的问题，无法选择出最短的路径。原因就在与 **前面的选择影响到了后面的选择**，（如果第一步选择了A路径，那么只能选择紧接着A的E、F路径，而因为第一步未选择B路径，那么也就无法选择紧接着B路径的C和D，所以起前面的选择影响到了后面的选择）

> 可以发现两种存在区别，也就是 题设要求解的问题对于每一步选择是否会影响到后面的选择，如果会影响，那么不适用于贪心算法，不影响的话还得继续分析

# 分治算法

分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问 题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，再合并其结果，就得到原问题的解。

> **分治算法是一种处理问题的思想，递归是一种编程技巧。** 分治算法一般都比较适合用递归来实现

**分治算法的递归实现，每一层递归都会涉及到三个操作：**

1. 分解：将原问题分解成一系列子问题； 
2. 解决：递归地求解各个子问题，若子问题足够小，则直接求解；
3. 合并：将子问题的结果合并成原问题。

**分治算法能解决的问题，一般需要满足下面这几个条件：**

1. 原问题与分解成的小问题具有相同的模式； 原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别
2. 具有分解终止条件，也就是说，当问题足够小时，可以直接求解
3. 可以将子问题合并成原问题，而**这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了**

### 二分搜索技术

分治法的典型例子，给定一个排序好的数组 a , 数组大小为 n , 现在要求搜索到 值为  x 的值的序号，用分治法的思想就是将数组划分为两份，将x与中间值比较，如果大于中间值，则将中间值前部分为一个数组，继续划分为两份，比较中间值，直到要搜索的值与中间值相等，即输出 

此算法的 时间复杂度 为 O（logN）

```java
int binarySearch (int[] nums, int left, int right, int x) 
{
  while (left <= right) {
		int medium = (left + right) / 2;
    if (nums[medium] < x) 
      binarySearch(nums, medium+1, right, x);
    else if (nums[medium] > x) 
      binarySearch(nums, left, medium+1, x);
    else  
      return medium 
  }
  return -1
}
```

### 归并排序

所谓归并[排序](https://baike.baidu.com/item/排序)是指将两个或两个以上有序的数列（或有序表），合并成一个仍然有序的数列（或有序表）。这样的排序方法经常用于多个有序的数据文件归并成一个有序的数据文件。归并排序的算法比较简单。

稳定在 O（logN）

**归并操作的工作原理**如下：

1. 第一步：申请空间，使其大小为两个已经[排序](https://baike.baidu.com/item/排序)序列之和，该空间用来存放合并后的序列
2. 第二步：设定两个[指针](https://baike.baidu.com/item/指针)，最初位置分别为两个已经排序序列的起始位置
3. 第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针超出序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾

归并排序算法：

```java
public class MergeSort {
    // 将函数内部数组不断分解为一半，在最后的return 过程中，先将最小的半部分序列有序排列好，返回继续与另外半部分进行比较合并，完成部分的有序（解决小问题），直到解决大问题
    public int [] sort (int[] sourceArray) {
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        if (arr.length < 2) {
            return arr;
        }
        int middle = (int) Math.floor(arr.length / 2);

        int[] left = Arrays.copyOfRange(arr, 0, middle);
        int[] right = Arrays.copyOfRange(arr, middle, arr.length);
      
        return merge(sort(left),sort(right));
    }
  
    protected int[] merge(int[] left, int[] right) {
        int[] result = new int [left.length + right.length];
        int i = 0;
        // 进行合并比较，移动指针向后，这里是不断更改数组，首元素存储进去后，继续修改数组，使第二个元素为第一个数组
        while (left.length > 0 && right.length > 0) {
            if (left[0] <= right[0]) {
                result[i++] = left[0];
                left = Arrays.copyOfRange(left,1,left.length);
            } else {
                result[i++] = right[0];
                right = Arrays.copyOfRange(right,1,right.length);
            }
        }
        //当比较中有一部分指针已经指向到了 最后，剩余的部分可以直接合并加入
        while (left.length > 0) {
            result[i++] = left[0];
            // 移动指针向后，这里是不断更改数组，首元素存储进去后，继续修改数组，使第二个元素为第一个数组
            left = Arrays.copyOfRange(left, 1, left.length);
        }

        while (right.length > 0) {
            result[i++] = right[0];
            right = Arrays.copyOfRange(right, 1, right.length);
        }、
        return result;
    }
}

```

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithm无标题的笔记本 (1)-2-7625874.jpg)

### 快速排序

### 循环日程安排问题

设有 n = 2 ^k^ 个选手进行网球循环赛，设计一个满足以下要求的比赛日程：

1. 每个选手必须与其他 n - 1个选手各赛一次
2. 每个选手一天只能比赛一次
3. 循环赛在 n - 1 天之内结束

**解题思路**：

[解题思路](https://zhuanlan.zhihu.com/p/138098393)

解题要点：此题是一个自底向上的迭代过程，通过刻画二维表可以发现规律，当只有两个选手的时候，很容易写出他的二维表，当 k = 2 时，即有 4 个选手时，可以发现 其二维表的 值 是 可以基于 k =1 (2) 的二维表来编写，将二维表划分为四大块，左上角就是上一个二维表，左下角是上一个二维表的基础上 加上 一个值(值为 2 ^k-1^) ，右上角与左上角是一样的，右下角和左上角是一样的。

在做程序处理的时候，注意把对应的值赋值到到应的二维数组位置里

是先已知两个人时的二维表，然后求出，4个人的二维表，再求出 8 个人的二维表，直到求出 2 ^k^ 人次的二维表

**程序算法**：

```java
package com.algorithmCourse.DivideAndConquer;

public class CircularSchedule {

    static int[][] a = new int[101][101];

    public void plan (int k) {
        int i,j,temp,n,t;
        n = 2;              // 初始已知两个人的安排
        a[1][1]=1;
        a[1][2]=2;
        a[2][1]=2;
        a[2][2]=1;

        for (t = 1; t < k; t++) {

            temp = n;               // 要右上角（左下角）部分要添加的 值 , 添加的值为 2 ^k-1^ 
            n = n * 2;              // n 在这里表示在 2 ^t^ 下 ，二维表的边界 
            
                                                        //  左上角已有，就是 2 ^t-1^ 的二维表值
                    

            for (i = temp + 1; i <= n; i++) {           //   填充左下角元素
                for (j = 1; j <= temp; j++) {
                    a[i][j] = a[i - temp][j] + temp;
                }
            }
            for (i = 1; i <= temp; i++) {               //   填充右上角元素
                for (j = temp + 1; j <= n; j++) {
                    a[i][j] = a[i + temp][j - temp];
                }
            }

            for (i = temp + 1; i <= n; i++) {           //   填充右下角元素
                for (j = temp + 1; j <= n; j++) {
                    a[i][j] = a[i - temp][j - temp];
                }
            }
        }
    }

    public static void main(String[] args) {
        CircularSchedule test = new CircularSchedule();
        int k = 3;
        double n = Math.pow(2.0,k);
        test.plan(3);
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++ ) {
                System.out.print(a[i][j] + ",");
            }
            System.out.println("");
        }
    }
}
```

### 订单金额排序问题

有10GB的订单，现在需要将订单按照金额来排序好成为一个有序的订单集合，由于内存一般都是2GB 的大小限制，所以无法来处理这么大量的数据，而我们就可以使用分治算法的思想来解决这一问题，将订单划分为多个组成部分，比如 2G大小的内存 一组，将0-100的放在一组，将100-200的放在一组，然后将各组进行内部排序，再整体进行排序，而内部又可以继续分类，类里排序，排序后再整体拍序，递归下去

# 回溯算法

## 总结

很多经典的数学问题都可以用回溯算法解决，比如数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列、正则表达式匹配

笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是狭 义的指我们前面讲过的图的搜索算法，而是在一组可能的解中，搜索满足期望的解。**回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段， 我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期 望的解），就回退到上一个岔路口，另选一种走法继续走。** 

**针对回溯算法的递归过程，最好打印递归执行的位置，通过画图，或者构想出，树状结构的执行过程会很好理解（推荐）**

**回溯算法的效率不太好，通过剪枝来减少一些不必要的递归是非常有必要的**

回溯算法通常的格式：

1. 进入递归处理函数，for循环遍历各个选项（不同的供应商，皇后问题的各个列）
2. 不满足剪枝的条件，对数据进行处理（存进数组，累加值等）
3. 进入下一个零件（皇后问题的下一行）的选择，即递归 （阶段变量 i +1）
4. 进入到递归后，依旧是这个for 循环，还是从头开始，（也就是继续从第一个供应商开始选择，继续从第一列选择）
5. 进行剪枝判断，如果符合剪枝条件，执行剪枝条件，一般都是 return 或者 continue 结束本次for循环
6. 继续执行下一次 for 循环 ，继续进行递归
7. 如果递归到满足条件（所有零件遍历结束，所有行遍历结束），可以输出结果或者存储结果，同时结束递归

代码框架：

```c
backtrack(1);
int x[n]														// 存放解向量，为全局变量
void backtrack(int i) 							// 求解子集树的递归框架
{
  if (i > n) 												// 搜索到叶子节点，输出一个可行解
    输出结果;
  else
  {
    for(j=下界;j<=上界;j++) {					// 用 j 来枚举 i 所有可能的路径
      x[i] = j;											// 产生一个可能的解分量
      其他操作
      if(constraint(i) && bound(i)){		// 剪枝，满足条件进入下一层
             backtrack(i+1)
      }
  }
}
```

> 1. 脑中有树状的结构图，即解空间树
> 2. 回溯框架中可以传递多个参数，比如存储数据的数组

**如果拓展路径的只有两条（01背包问题，只有选择与不选择问题），就不必用for循环了，直接使用两个递归即可，一个递归表示选择，参数中存储数据的数组加数据，递归进去，一个递归表示不选择，参数中存储数据的数组不加进去，递归进去，两个递归写在一起即可 ，但是大多数实际问题还是有多个选项（多个拓展路径），所以使用for循环来解决（零件选择多个供应商问题）**

### 回溯法和深度优先遍历的区别

1. 访问次序不同

   深度优先重要的是遍历，本质是无序的，访问次序是不重要的，重要是否被访问过，回溯法的目的是“求解过程”，本子是有序的

2. 访问次序不同

   深度优先遍历对已经访问过的顶点不再访问，所有顶点仅访问一次，回溯法可能访问多次

3. 剪枝不同

   深度优先遍历不做剪枝，访问所有，回溯通常有剪枝处理

**关联：“回溯法 = DFS  + 剪枝” ，自带回退的都可以称为回溯算法**

### 0/1 背包问题

归纳在动态规划部分

代码：

```c
void dfs(int i,int tv,int op[]) 
{
  if(i>n) {
    maxv = tv;
    for(int j = 1; j < n; j++) {
      x[j] = op[j];
    } 
  }
  else {
    if (w + A[i].w < W) {									// 剪枝
      op[i] = 1;
      dfs(i+1,tw+A[i].w,tv+A[i].v,op)
    }    
    if (bound(i,tw,tv)>maxv)   {				//  剪枝
      op[i] = 0;
      dfs(i+1,tw,tv,op)
    }
  }
}
```

不剪枝直接两个递归就可以解决

### 求解图的m着色问题

给定无向联通图G和m种不同的颜色，用这些颜色为图G的各个顶点着一种颜色，如果有一种着色法使G中的每条边的两个顶点着不同颜色，则称这个图是 m 可着色的，图的 m 着色问题是对于给定图 G 的 m 种颜色，找出所有不同的着色法

用java实现

### 购买零件选择不同供应商问题

设某一机器由n个部件组成，每一种部件都可以从m个不同的供应商处购得。wij 是从供应商j处购得的部件 i 的重量， cij 是相应的价格。通过每个零件在各个供应商中选择最合适的，使其总价格不超过 c 的最小重量机器设计。

使用回溯算法，第一个零件在第一个供应商处购买，（递归进去）第二个零件也在第一个供应商购买，直到第n个零件也在第一个供应商处购买，遇到跳出循环的判断，此时输出一个结果，最后一层的for循环在 i = 1的时候（也就是最后一个零件选择第一个供应商的时候）执行完毕了，继续回到原来进入到最后一层的递归位置，继续向下执行，执行到 i = 2，即第n个零件选择第二家供应商，同理分别选择完m个供应商后，输出可m个结果，继续回到其上一层进入递归的地方，i = 2，即第 n-1 个零件选择第二个供应商，直到到最外层循环，即第一个供应商的选择，最后所有的结果遍历完毕，递归结束

也就是说如果不使用剪枝的话，一共有 m^n 个结果 ，这也就是回溯算法的精髓，枚举所有，递归再回溯

### 8个棋子的皇后问题

我们有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。

我们把这个问题划分成 8 个阶段，依次将 8 个棋子放到第一行、第二行、第三行……第八 行。在放置的过程中，我们不停地检查当前的方法，是否满足要求。如果满足，则跳到下一 行继续放置棋子；如果不满足，那就再换一种方法，继续尝试。

```java
public class Huisuo {

	public static void main(String[] args) {
		int[] result = new int[8];// 全局或成员变量, 下标表示行, 值表示 queen 存储在哪一列
		cal8queens(0,result);	// 表示从第0行开始
	}
	
	public static void cal8queens(int row,int[] result) { // 调用方式：cal8queens(0);
		 if (row == 8) { // 8 个棋子都放置好了，打印结果
			 printQueens(result);
			 return; // 8 行棋子都放好了，已经没法再往下递归了，所以就 return
		 }
		 for (int column = 0; column < 8; ++column) { // 每一行都有 8 中放法
			 if (isOk(row, column, result)) { // 有些放法不满足要求
				 result[row] = column; // 第 row 行的棋子放到了 column 列
				 cal8queens(row+1, result); // 考察下一行
			 }
		 }
	}
		
	private static boolean isOk(int row, int column, int[] result) {// 判断 row 行 column 列放置是否合适
	 int leftup = column - 1, rightup = column + 1;
	 for (int i = row-1; i >= 0; --i) { // 逐行往上考察每一行	因为下层的还没有填补不必考虑
		 if (result[i] == column) return false; // 第 i 行的 column 列有棋子吗？
		 if (leftup >= 0) { // 考察左上对角线：第 i 行 leftup 列有棋子吗？
			 if (result[i] == leftup) return false;
		 }
		 if (rightup < 8) { // 考察右上对角线：第 i 行 rightup 列有棋子吗？
			 if (result[i] == rightup) return false;
		 }
		 	--leftup; ++rightup;
	 	}
	 	return true;
	}
	
	private static void printQueens(int[] result) { // 打印出一个二维矩阵
	 for (int row = 0; row < 8; ++row) {
		 for (int column = 0; column < 8; ++column) {
			 if (result[row] == column) System.out.print("Q ");
			 else System.out.print("* ");
		 }
		 System.out.println();
	 }
	 System.out.println();
	}
}
```

> 整体就三个部分，三个处理函数：
>
> 1. 填补数据：负责填补数值到数组中，填补的方式是数组的下标是对应的行，数组的值就是对应的列，
> 2. 检验此位置是否可以填补：负责判断是否可以放置在这个位置，传递正在处理的行row进来，检验row以上的行同列是否存在数值，以及对角线是否存在，每向上一行，负责检验对角线的 leftup 和 rightup 就加1 （满足对角线）
> 3. 输出数组数据：双层循环输出，满足每行都存在一个列值，遍历检验，存在即输出Q ,不存在即输出 *

输出结果比如：

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20201015164307351.png)

# 分枝限界法

## 总结

分枝限界法类似于回溯法，也是一种在解空间树上搜索问题解的算法，回溯法的求解目标是求解出，满足约束条件的所有解，而分枝限界法求解的目标是找出满足目标条件的一个解，或者是某种意义上的最优解，使某个函数式达到最大值或者最小值

所谓分枝，就是采用广度优先的策略依次搜索活节点的所有分枝，也就是所有的相邻节点，为了有效的选择在一拓展节点，在每一个活节点处计算一个函数值（限界函数），并根据这个已计算出的函数值从当前活节点表中选择一个最有利的节点作为拓展节点，以便最快的找到最优解

分枝限界法精华在于处理的数据结构是 队列，而队列这种结构十分适用于广度优先遍历这种处理思路（栈十分适用于深度优先遍历），队列的性质，决定了不需要递归，在处理 类似于01背包问题的多物品选择问题时，利用队列来存储各个选择后状态，通过设定 最大期望值 来剪枝 ，针对于 单源点最短路径问题类似问题时，这种题目的特点一方面是数据是矩阵类型，拓展节点拓展的是相邻节点，也是刻画 此节点到源节点的最短距离变量 来剪枝（同时也是要求的值），刻画一个 pre 指针数组，十分巧妙的把路径记录下来

### 分枝限界法于回溯法的区别

| 方法       |              |                |                                            |                                          |
| ---------- | ------------ | -------------- | ------------------------------------------ | ---------------------------------------- |
| 回溯法     | 深度优先遍历 | 栈             | 活节点的所有可行子结点被遍历后才从栈中出栈 | 找出满足条件的所有解                     |
| 分枝界限法 | 广度优先遍历 | 队列、优先队列 | 每个节点只有一次成为活节点的机会           | 找出满足条件的一个解或者特定意义的最优解 |

### 0/1 背包问题

在01背包问题中，对每个物品都有选择与不选两种选择，可以把整个过程刻画为一个树状的结构，也更加方便理解，树的高度为 物品数+ 1（加个根节点，即什么都还没选的时候），当选择这个物品时就表示为左节点，不选择就表示为右节点，程序会记录选择的过程，最后叶子节点为一个结果

程序中刻画了两种结构体（两个类），一个是描述物品的物品类（即描述了本物体的质量和本物体的价值），一个是为放置到队列的设计的 node （描述了此节点存储了前面各个物品状态下的质量和，以及价值和，同时还存储了最大期望价值），队列中的 node 意义 ，表示在选择到某个物品后到状态，比如说我已经选择到第三个物品，前面两个物品都是选择了，第三个没选择，那么 node 表示此时的状态，而 node 内部的属性 weight 表示的就是前两个物品的质量加上第三个物品的质量 0 （没选上），node 内部的 value 也是如此，而 node 的 boundValue 值即表示为在前三个物品选取状态下（即110）的 value + 后续还未选择的所有物品的质量 （即最理想状态），那么 队列是如何拓展节点的呢，就是通过遍历各个物品，每个物品有两个状态，一个左节点（选择），一个右节点（不选择），程序来判断。如果满足最大质量要求，且其 最理想的值 大于前面程序计算出来的值（同时记录最大值），说明其还有可能产生最大价值，所以把这个节点（这个状态）存储到队列中，左右节点都是如此 （剪枝），最后直到队列为空，输出最大值

> 这里与单源点多向图最短路径问题存在不同，后者的队列拓展节点是遍历相邻节点，队列中存储的是各个节点，而01背包问题中队列中存储的是选择到某个物品的状态

### 单源点多向图最短路径问题

多向图问题中，自定义矩阵类型的数据，输入以某点作为源点，然后程序以此点为中心，生成到各个点的最短距离，记录输出

先将头节点（开始是源节点）存储到队列中，遍历此头节点的相邻节点，如果头节点的长度加上头节点到此节点的长度小于之前程序计算出此节点到源节点的距离（或者默认值）（dist数组存储），那么就替换这个值，记录此头节点为此节点的前指针节点，并将其存储到队列中，如果长度之和还大于原先计算出的值（即之前计算的最短路径），剪枝，不把此节点压入队列，反复推出头节点的值，计算和压入其相邻节点，直到队列为空，执行完毕，最后在 dist 数组 和 pre 数组，根据编号对应索引可以查询到源节点到此节点的最短路径和此节点到源节点的路径的前置节点编号

用分枝限界法来解决时，存在两种队列来处理，一种是普通的队列，将符合条件的压入队列中，输出按照头部节点输出，一种是优先队列，即在压入队列后，在队列中会根据队列中定义的比较函数，根据某个标准（即优先级）来将优先级高的放在优先队列的头部，通过排序将优先级高的放置在前面，那么就可以较早的找到到某点的最短路径，那么后续大部分的节点都会因为不符合条件而被剪枝，极大的优化程序

> 具体查看代码

# 动态规划

## 总结

**动态规划问题的一般形式就是求最值**，比如说让你求**最长**递增子序列呀，**最小**编辑距离呀等等。

**求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。

> 在求解最长公共子序列问题时，也是基于穷举的，在给予两个子串构建 dp 表时，也是使用的 两层 for 循环，一个个字符穷举比较，如果两个字符相等，dp表中的对应位置 在前面的基础上 加 1，不相等在取另外两个的最大值，最后填充好 dp 

**动态规划的三要素：重叠子问题、最优子结构、状态转移方程**

1. 动态规划的穷举有点特别，因为这类问题**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。
2. 动态规划问题一定会**具备「最优子结构」**，才能通过子问题的最值得到原问题的最值。
3. 动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出**正确的「状态转移方程**」才能正确地穷举。

> 在求解最长公共子序列问题中，重叠子问题和最优子结构体现在于，长一点的子串都是基于短子串，求解长子串的最长公共子序列其实是先求出短一点的子串最长公共子序列，都是求的最长的，那么最后的结果也是最长的，即满足最优子结构

关于写出状态转移方程的思维框架：明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。

> **计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举**，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。
>
> 列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。
>
> 备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，

**个人总结**

**关于动态规划的问题，都是需要申请一个额外的数组空间去存储数据，并且都是由小问题递推出大问题，也就是根据递推关系推导出后面的数据，也就是类似于备忘录的功能，缺点就是要额外申请空间，而能用动态规划解决的问题都可以用 回朔法来解决（通常是两层递归，选择与不选择，向左与向右），程序代码简单，但是是时间复杂度比较高，回溯法 添加一个数组来标记作用或者简单的存储数据，也就是相当与 备忘录 功能**

**而动态规划的难点，就在于建表的过程，一个是需要递推公式，另外一个是构建一个二维数组，如何来定义 这个数组的意义，比如说 行号表示什么，列号表示什么，行列对应的存储值又是表示什么，另外还需要注意到二维数组遍历变量的值的处理，最好是画一个二维表的图来，这样在后续输出和读表的过程都十分清晰，（一般要的结果都是dp数组的最后一位存储的，需要遍历过程的题目稍微麻烦一点，像求导最长公共子序列问题中，需要分析，看表来输出）**

### **“一个模型三个特征”**

“**一个模型**”？它指的是动态规划适合解决的问题的模型。我把这 个模型定义为**“多阶段决策最优解模型”**。

“**三个特征**”？它们分别是**最优子结构、无后效性和重复子问题。**

1. 最优子结构。问题的最优解包含子问题的最优解，也就是可以通过子问题的最优解，推导出问题的最优解（后阶段的状态可以通过前面的阶段状态推导出来）
2. 无后效性。在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步的推导出来的，某阶段一旦确定，就不受之后阶段的影响
3. 重复子问题，不同的决策序列，到达某个相同的阶段的时候，可能会产生重复的状态

**验证这个模型**

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20201016105600410.png)

**符合模型 多阶段决策最优解问题** ：从 (0, 0) 走到 (n-1, n-1)，总共要走 2*(n-1) 步，也就对应着 2*(n-1) 个阶段。每个阶段都 有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。，我们把状态定义为 min_dist(i, j)，其中 i 表示行，j 表示列。min_dist 表达式的值表示从 (0, 0) 到达 (i, j) 的最短路径长度。所以，这个问题是一个多阶段决策最优解问题，符合动 态规划的模型。

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20201016105600410.png)

**符合特征 重复子问题**：我们可以用回溯算法来解决这个问题。如果你自己写一下代码，画一下递归树，就会发现， 递归树中有重复的节点。重复的节点表示，从左上角到节点对应的位置，有多种路线，这也 能说明这个问题中存在重复子问题。

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20201016105847874.png)

**符合特征 无后效性：**如果我们走到 (i, j) 这个位置，我们只能通过 (i-1, j)，(i, j-1) 这两个位置移动过来，也就是说，我们想要计算 (i, j) 位置对应的状态，只需要关心 (i-1, j)，(i, j-1) 两个位置对应的状态，并不关心棋子是通过什么样的路线到达这两个位置的。而且，我们仅仅允许往下和往右移动，不允许后退，所以，前面阶段的状态确定之后，不会被后面阶段的决策所改变，所以，这个问题符合“无后效性”这一特征。

**符合特征 最优解子结构：**刚刚定义状态的时候，我们把从起始位置 (0, 0) 到 (i, j) 的最小路径，记作 min_dist(i, j)。 因为我们只能往右或往下移动，所以，我们只有可能从 (i, j-1) 或者 (i-1, j) 两个位置到达 (i, j)。也就是说，到达 (i, j) 的最短路径要么经过 (i, j-1)，要么经过 (i-1, j)，而且到达 (i, j) 的 最短路径肯定包含到达这两个位置的最短路径之一。换句话说就是，min_dist(i, j) 可以通 过 min_dist(i, j-1) 和 min_dist(i-1, j) 两个状态推导出来。这就说明，这个问题符合“最优子结构”。

`min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))`

### 解决动态规划的两种思路

#### 状态转移表法

**一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，当我们拿到问题的时候，我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复 子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。 找到重复子问题之后，接下来，我们有两种处理思路，第一种是直接用回溯加“备忘录”的 方法，来避免重复子问题。从执行效率上来讲，这跟动态规划的解决思路没有差别。第二种 是使用动态规划的解决方法，状态转移表法。**

动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。

**我们先画出一个状态表。状态表一般都是二维的，所以你可以把它想象成二维数组。其中， 每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表的过程，翻译成代码， 就是动态规划代码了。**

> 尽管大部分状态表都是二维的，但是如果问题的状态比较复杂，需要很多变量来表示，那对应的状态表可能就是高维的，比如三维、四维。那这个时候，我们就不适合用状态转移表法 来解决了。一方面是因为高维状态转移表不好画图表示，另一方面是因为人脑确实很不擅长思考高维的东西。

**第一步先用回溯算法解题**

**回溯法解决上述棋子最短路径问题**（使用双递归）

```java 
private int minDist = Integer.MAX_VALUE

    public void minDistBT(int i, int j, int dist, int[][] w, int n) {
    if (i == n && j == n) {
        if(dist < minDist) minDist = dist;
        	return;
    }
    if (i < n) {
        minDistBT(i + 1, j, dist+w[i][j], w, n)
    }
    if (j < n) {
        minDistBT(i, j+1, dist+w[i][j], w, n)			// 注意到回退时，dist 前面加的值也回退了
    }
}
```

**第二步画递归树，找重复子问题**

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20201016153433708.png)

在递归树中，一 个状态（也就是一个节点）包含三个变量 (i, j, dist)，其中 i，j 分别表示行和列，dist 表示 从起点到达 (i, j) 的路径长度。从图中，我们看出，尽管 (i, j, dist) 不存在重复的，但是 (i, j) 重复的有很多。(i,j) 重复表示的就是到达一个位置，存在多种方法，**对于 (i, j) 重复的节点，我们只需要选择 dist 最小的节点，继续递归求解， 其他节点就可以舍弃了（减少递归基数，也就是动态规划的精华）**

**==第三步画一个二维状态表==**

表中的行、列表示棋子所在的位置，表中的==数值表示从起点到这个位置的最短路径==。我们按照决策过程，通过不断状态递推演进，将状态表填好。为了方便代码实现，我们==**按行**==来进行依次填充。

![image-20210221104619370](/Users/yummy/Library/Application%20Support/typora-user-images/image-20210221104619370.png)

> **注意表中填充的值是在上一状态集合中选出 本位置的上状态中最小的路径和 和 本位置的左状态中最小的路径和 分别与 本位置的路径长度 相加，最后对比出最小的值填入到这个空中**
>
> 具体可以对照题目中的数值对应 

==**第四步根据填表过程翻译为代码**==

```java
public int minDistDP(int[][] matrix, int n) {
    int[][] states = new int[n][n];
    int sum = 0;
    for (int j = 0; j < n; ++j) { // 初始化 states 的第一行数据
        sum += matrix[0][j];
        states[0][j] = sum;
    }
    sum = 0;
    for (int i = 0; i < n; ++i) { // 初始化 states 的第一列数据
        sum += matrix[i][0];
        states[i][0] = sum;
    }
  
    for (int i = 1; i < n; ++i) {
        for (int j = 1; j < n; ++j) {
            states[i][j] = matrix[i][j] + Math.min(states[i][j-1], states[i-1][j]);
        }
    }
  
    return states[n-1][n-1];
}
```

**总体过程：回溯算法实现 - 定义状态 - 画递归树 - 找重 复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码**

> 与最长公共子序列问题中对比，也都是先推导出 递推公式，刻画 dp 表，初始化表，根据递推公式来填表（也都是取的两者的最值，加上自己本身数据或者做加减计量运算来填充自己），从而构建了一个 dp 表，最后一般最后推导出来的那个值 dp[n]/[m] 存储的就是要求的值，如果想要求解出组成元素，根据 dp 表推导过程可以逆向输出组成元素

#### 状态转移方程法                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常简单了。一般情况下，我们有两种代码实现方法，一种是递归加“备忘录”，另一种是迭代递推。

状态转移方程： `min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))`

状态转移方程是解决动态规划的关键。如果我们能写出状态转移方程，那动态规划问题基本上就解决一大半了，而翻译成代码非常简单。但是很多动态规划问题的状态本身就不好定义，状态转移方程也就更不好想到。

用递归加“备忘录”的方式，将状态转移方程翻译成来代码

```java
private int[][] matrix = {{1，3，5，9}, {2，1，3，4}，{5，2，6，7}，{6，8，4，3}};
private int n = 4;
private int[][] mem = new int[4][4];
public int minDist(int i, int j) { // 调用 minDist(n-1, n-1);
    if (i == 0 && j == 0) return matrix[0][0];
    if (mem[i][j] > 0) return mem[i][j];
    int minLeft = Integer.MAX_VALUE;
    if (j-1 >= 0) {
        minLeft = minDist(i, j-1);
    }
    int minUp = Integer.MAX_VALUE;
    if (i-1 >= 0) {
        minUp = minDist(i-1, j);
    }

    int currMinDist = matrix[i][j] + Math.min(minLeft, minUp);
    mem[i][j] = currMinDist;
    return currMinDist;
}
```

> 不是每个问题都同时适合这两种解题思路。有的问题可能用第一种思路更清晰，而有的问题可能用第二种思路更清晰，所以，你要结合具体的题目来看，到底选择用哪种解题思路。

此题的状态转移方程法对比回溯法：

**回溯法是由起始点开始向结果递归，状态转移方程法是由终点向子问题递归**

```java
private int minDist = Integer.MAX_VALUE

public void minDistBT(int i, int j, int dist, int[][] w, int n) {
  if (i == n && j == n) {
    if(dist < minDist) minDist = dist;
    	return;
  }
  if (i < n) {
    minDistBT(i + 1, j, dist+w[i][j], w, n)
  }
  if (j < n) {
    minDistBT(i, j+1, dist+w[i][j], w, n)			// 注意到回退时，dist 前面加的值也回退了
  }
}
```

**状态转移方程法的大致思路可以概括为，找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码。**

## **实例分析**

### 斐波那契数列

典型的递归问题，但是存在一个很明显的问题，就是进行了多次重复计算，效率非常低，也就是重叠子问题，进而进行优化，构造一个备忘录，将要求的值，先通过一个函数来处理，如果计算这个值在备忘录（数组）中不存在，那么就进行计算，存储并返回，如果存在这个值，则直接从其中读取即可，即避免重复和不必要的开销，实现了递归算法的优化。

**这种递归算法称为自顶向下，也就是我想要求这个值，我得先求得另外的值（子问题的值），依次递归下去求出最底层的值，然后最后一层层的返回才求出这个值，这是递归的调用的特点**

**而动态规划与这恰恰相反，而是一种 自底向上的求解思路，我想要求 f(20)，我先求出 f(1) ,和 f(2) 的值 ，然后依次向上相加求出 f(3) ... f(20) ，也就是从底层向上求， 这种方法和 添加了备忘录的递归方法 时间复杂度 和效率是一样的** 

举例斐波那契数列这个例子，就是为了说明两点

1. 递归算法是自顶向下，而动态规划是自底向上
2. 斐波那契数列就存在重叠子问题，用动态规划来解决就是用一个表先计算且存储在一个表中（从底层向上计算），然后查询调用即可

**关于状态转移方程**

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20201012202311052.png)

状态转移方程是什么？**把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移**

你会发现，上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，**都是围绕这个方程式的不同表现形式**

所以求解出 状态转移方程才是要点

如何推导出 [状态转移方程](https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6.md)

为什么需要动态规划？

动态规划是如何演变而来的？

会总结动态规划适合解决的问题的特征，以及动态规划解题思路

## 0/1 背包问题

### **回溯算法（加备忘录）**：

```java
private int maxW = Integer.MIN_VALUE; // 结果放到 maxW 中
private int[] weight = {2，2，4，6，3}; // 物品重量
private int n = 5; // 物品个数
private int w = 9; // 背包承受的最大重量
private boolean[][] mem = new boolean[5][10]; // 备忘录，默认值 false

public void f(int i, int cw) { // 调用 f(0, 0)
    if (cw == w || i == n) { // cw==w 表示装满了，i==n 表示物品都考察完了
        if (cw > maxW) maxW = cw;
        return;
    }
    if (mem[i][cw]) 
      return; // 重复状态
  
    mem[i][cw] = true; // 记录 (i, cw) 这个状态
  
    f(i+1, cw); // 选择不装第 i 个物品
  
    if (cw + weight[i] <= w) {
        f(i+1,cw + weight[i]); // 选择装第 i 个物品
    }
}
```

### 动态规划算法

```java
// weight: 物品重量，n: 物品个数，w: 背包可承载重量
public int knapsack(int[] weight, int n, int w) {
    boolean[][] states = new boolean[n][w+1]; // 默认值 false
    states[0][0] = true; // 第一行的数据要特殊处理，可以利用哨兵优化
    states[0][weight[0]] = true;
    for (int i = 1; i < n; ++i) { // 动态规划状态转移
        for (int j = 0; j <= w; ++j) {   // 不把第 i 个物品放入背包
            if (states[i-1][j] == true) 
              states[i][j] = states[i-1][j];	
          		// 这一行表示不选择 第i个物品，也是一种结果，实际这里 赋值变量 states[i-1][j] 的值为true，当第 i-1层有标记时
          		// 这里又表示不选择，所以 i 层不选择，其对应的j不处理(也就是重量不变)，但是标记，
        }
        for (int j = 0; j <= w-weight[i]; ++j) {        // 把第 i 个物品放入背包  注意到范围，否则j 会超出数组的大小
            if (states[i-1][j] == true) 
              states[i][j+weight[i]] = true; 
          	// 这一行来负责选择 第i 个物品，那么结果是在原来的基础结合上，即states[i-1][j]的基础上，选择第i个物品，
          	// 所以第i 个物品的 重量要在原来的基础上，加上第i个物品的质量
        }
    }	
    for (int j = w; j >= 0; --j) { // 输出结果
        if (states[n-1][j] == true) return j; // 输出末行的最后第一个有状态的值
    }
    return 0;
}
```

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20201015202014360.png)

> 1. **注意理解 states 这个数组的意义，`states[i][j] = booleans` 其中 i 表示第几个物品，题设是 以 0 为起始，j 表示背包在选择到第i+1 个物品时的背包质量 ，而 booleans 在这里表示标记，即标记 `states[i][j]` 第 i + 1 个 物品质量为 j 的上一状态，为后续选择为基础**
> 2. **还有一点要注意到，二维数组的最大横轴偏移是 背包所承受的质量+1 ，纵轴偏移表示的为 可选物品的数量 (因为以0起始)**
> 3. **最后 本题的时间复杂度 主要集中在 两层 for 循环中，为 O(n*w） 即物品数量乘以 最大质量**

### **对比回溯算法**

1. **在时间复杂度上： 回溯算法的时间复杂度是指数级别的 O(2^n^) ，而动态规划的时间复杂度为 O(n * w)**

2. **动态规划的相对于回溯法的精髓：我们把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合， 来推导下一层的状态集合。我们可以通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过 w 个（w 表示背包的承载重量）成功避免了每层状态个数的指数级增长。**

3. **动态规划也有明显的缺点，就是刻画的数组，需要占用一定量的空间即需要额外申请 n * w+1 的二维数组，所以说动态规划是一种空间换时间的解决思路**

   > **动态规划的关键在于，在每进行完一次选择后，会将重复的问题进行合并，从而减小了问题的规模**


**简化版：**

   申请一个一维数组也能完成（也就是不记录第几个物品了）

   ```java
   public static int knapsack2(int[] items, int n, int w) {
       boolean[] states = new boolean[w+1]; 					// 默认值 false
       states[0] = true; 															// 第一行的数据要特殊处理，可以利用哨兵优化
       states[items[0]] = true;
       for (int i = 1; i < n; ++i) { 									// 动态规划
           for (int j = w-items[i]; j >= 0; --j) {		// 把第 i 个物品放入背包
               if (states[j]==true) 
                 states[j+items[i]] = true;
           }
       }
       for (int i = w; i >= 0; --i) { 								// 输出结果
           if (states[i] == true) return i;
       }
       return 0;
   }
   ```

>    第 6 行，j 需要从大到小来处理。如果我们按照 j 从小到大处 理的话，会出现 for 循环重复计算的问题 

### 背包问题升级版

在限制最大质量的情况下，再次追求最大价值，也就是每个单品本身也存在价格]

#### 回溯法实现

```java
private int maxV = Integer.MIN_VALUE; // 结果放到 maxV 中
private int[] items = {2，2，4，6，3}; // 物品的重量
private int[] value = {3，4，8，9，6}; // 物品的价值
private int n = 5; // 物品个数
private int w = 9; // 背包承受的最大重量
public void f(int i, int cw, int cv) { // 调用 f(0, 0, 0)
    if (cw == w || i == n) { // cw==w 表示装满了，i==n 表示物品都考察完了
        if (cv > maxV) maxV = cv;
        return;
    }
    f(i+1, cw, cv); // 选择不装第 i 个物品
    if (cw + weight[i] <= w) {
        f(i+1,cw+weight[i], cv+value[i]); // 选择装第 i 个物品
    }
}

```

> 第 11 行 选择不装第  i 个物品 代码十分巧妙 ，因为回溯算法实际就是递归来解题，而这里是先递归到最后物品，达到都不选的这一种结果上，然后依次回溯，将前 n-1 不选 ，最后一个选择，再次调用，进入更深层递归，实际也就完成了 二叉树的结构上从根节点到叶子节点的所有节点所组成的路径

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20201015211613542.png)

以上 回溯的递归算法可以实现，但是由图中二叉树的结构可以发现，仍然存在大量重复的节点，而这里又不便于使用备忘录来解决

#### 使用动态规划来优化

我们用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。不过这里数组存储的值不再是 boolean 类型的了，而是当前状态对应的最大总价值。我们把每一层中 (i, cw) 重复的状态（节点）合并，只记录 cv 值最大的那个状态，然后基于这些状态来推导下一层的状态。

```java
// value 数组存储的是 各个物品对应的价值
public static int knapsack3(int[] weight, int[] value, int n, int w) {
    int[][] states = new int[n][w+1];
    for (int i = 0; i < n; ++i) { // 初始化 states
        for (int j = 0; j < w+1; ++j) {
            states[i][j] = -1;
        }
    }
    states[0][0] = 0;
    states[0][weight[0]] = value[0];
    for (int i = 1; i < n; ++i) { // 动态规划，状态转移
        for (int j = 0; j <= w; ++j) { // 不选择第 i 个物品
            if (states[i-1][j] >= 0) 
              states[i][j] = states[i-1][j];
        }
        for (int j = 0; j <= w-weight[i]; ++j) { // 选择第 i 个物品
            if (states[i-1][j] >= 0) {
                int v = states[i-1][j] + value[i];
                if (v > states[i][j+weight[i]]) {
                    states[i][j+weight[i]] = v;
                }
            }
        }
    }
    // 找出最大值
    int maxvalue = -1;
    for (int j = 0; j <= w; ++j) {
        if (states[n-1][j] > maxvalue) 
          maxvalue = states[n-1][j];
    }
    return maxvalue;
}

```

时间复杂度是 O(n*w)，空间复杂度也是 O(n*w)。跟上一个例子类似，空间复杂度也是可以优化（用一维数组，不记录 i 即可）

```java
// value 数组存储的是 各个物品对应的价值
public static int knapsack3(int[] weight, int[] value, int n, int w) {
    int[] states = new int[w+1];
    for (int i = 0; i < n; ++i) { // 初始化 states
        for (int j = 0; j < w+1; ++j) {
            states[j] = -1;
        }
    }
    states[0] = 0;
    states[weight[0]] = value[0];
    for (int i = 1; i < n; ++i) { // 动态规划，状态转移
        for (int j = w-weight[i]； j >= 0; --j) { // 选择第 i 个物品
            if (states[j] >= 0) {
                int v = states[j] + value[i];
                if (v > states[j+weight[i]]) {
                    states[i][j+weight[i]] = v;
                }
            }
        }
    }
    // 找出最大值
    int maxvalue = -1;
    for (int j = w; j >= 0; --j) {
        if (states[j] > maxvalue) maxvalue = states[j];
    }
    return maxvalue;
}
```

## 购物满价格减免问题

假如满200减20的优惠政策，如何选择商品来满足这个条件，列出所有选项可能，并且输出每个选项集合中有哪些商品

```java
// items 商品价格，n 商品个数, w 表示满减条件，比如 200
public static void double11advance(int[] items, int n, int w) {
    boolean[][] states = new boolean[n][3*w+1];// 超过 3 倍就没有薅羊毛的价值了
    states[0][0] = true; // 第一行的数据要特殊处理
    states[0][items[0]] = true;
    for (int i = 1; i < n; ++i) { // 动态规划
        for (int j = 0; j <= 3*w; ++j) {// 不购买第 i 个商品
            if (states[i-1][j] == true) states[i][j] = states[i-1][j];
        }
        for (int j = 0; j <= 3*w-items[i]; ++j) {// 购买第 i 个商品
            if (states[i-1][j] == true) states[i][j+items[i]] = true;
        }
    }
    int j;
    for (j = w; j < 3*w+1; ++j) {
        if (states[n-1][j] == true) break; // 输出结果大于等于 w 的最小值
    }
    if (j == 3*w+1) return; // 没有可行解
    for (int i = n-1; i >= 1; --i) { // i 表示二维数组中的行，j 表示列
        if(j-items[i] >= 0 && states[i-1][j-items[i]] == true) {
            System.out.print(items[i] + " "); // 购买这个商品
            j = j - items[i];
        } // else 没有购买这个商品，j 不变。
    }
    if (j != 0) System.out.print(items[0]);
}
```

> 状态 (i, j) 只有可能从 (i-1, j) 或者 (i-1, j-value[i]) 两个状态推导过来。所以，我们就检查这 两个状态是否是可达的，也就是 `states[i-1][j] `或者 `states[i-1][j-value[i]] `是否是 true。 如果 `states[i-1][j] `可达，就说明我们没有选择购买第 i 个商品，如果 `states[i-1][j-value[i]] `可达，那就说明我们选择了购买第 i 个商品。我们从中选择一个可达的状态（如果两个都可 达，就随意选择一个），然后，继续迭代地考察其他商品是否有选择购买。

## 最长公共子序列问题

[清晰解读](https://blog.csdn.net/hrn1216/article/details/51534607)

子序列不等同与子串，他是可以不相连接的

在做推导时，是以两个序列的最后一个字符来做比较，相等的话，即在原来基础上减一个位的字符，求减去后的最长子序列，求出后 + 1即可，如果不相等，两条子序列中分别一个去掉其中一个字符，一个不去掉，最后最长子序列是取得做处理后的两条子序列中最大子序列的值

根据这个可以推出递归公式：

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20201211220214624.png)

C[i,j]的值即为最长子序列的长度，而 i ，j 分别表示两条子序列中的其中一条的指针，**c[i,j]整体的意义是，在第一条序列的 首位到第 i 位 和构成的子串 和 另一条序列的 的首位到 第 j 位构成的 子串 所相比最长公共子序列长度**

得到递推公式，我们如何来解决问题？这又如何体现了动态规划？

这种两条的子序列做对比的类型，不同长度不同位置可以产生多种结果，并且是一一对应的，所以我们需要用一个二维数组把对应位置的数据存储起来，也就是 dp 数组

题设做推导的时候是以最后一个字母做比较，而链接里和实现都是以第一位开始，向后推到，原理都是一样的，即要想求出 1234 与 1342 的最长公共子序列，先得把 12 和 13 的最长公共子序列求出，然后通过递推公式，再把  1234 与 1342 求出

在对 dp 数组进行填充的 时候，就是按照递推公式来推导的，翻译为代码，要求的最长公共子序列的值也就是 c[n]/[m] 中的值

再求出最长公共子序列的长度后，也可以通过 dp 数组将具体的公共字符串给倒序输出出来

> 最主要的还是要 理解 dp 数组 的存储的值的意义 和 横向 和 列 的意义 ，不可忽视数组的初始化部分

```java
package com.algorithmCourse.DynamicProgramming;

public class LongestSubsequence {

    // 建立 dp 表
    public int[][] createDp (String s1, String s2) {
        int n = s1.length();
        int m = s2.length();
        int[][] dp = new int[n+1][m+1];     // 建立的 dp 表要多一个单位，目的是使dp的某个单元格的值与子串的相对应
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 0;
        }
        for (int j = 0; j <= m; j++) {
            dp[0][j] = 0;
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
        return dp;
    }

    // 输出 公共子序列和最长公共长度
    public void disp (int[][] dp, String s1, String s2) {
        String ReverseResult = "";
        int n = dp.length - 1;
        int m = dp[0].length - 1;
        int i = n;
        int j = m;
        int LC = dp[n][m];              // LC 为 dp 表的最长公共子序列的长度，因为建表的时候，dp[n][m] 存储的就是最长公共子序列长度
        while ( LC > 0) {
            if ( dp[i][j] == dp[i-1][j]) {
                i--;
            } else if ( dp[i][j] == dp[i][j-1]) {
                j--;
            } else {
                ReverseResult += s1.charAt(i-1);
                i--;j--;LC--;
            }
        }
        String result = reverse(ReverseResult);
        System.out.println("最长公共子序列为：" + result);
        System.out.println("最长公共子序列长度为：" + dp[n][m]);
    }

    // 倒置字符串
    public String reverse (String str) {
        String result = "";
        int len = str.length();
        for (int i = len - 1; i >= 0; i--) {
            result += str.charAt(i);
        }
        return result;
    }

    public static void main(String[] args) {
        LongestSubsequence test = new LongestSubsequence();
        String s1 = "abcbdb";
        String s2 = "acbbabdbb";
        int[][] dp = test.createDp(s1, s2);
        test.disp(dp,s1,s2);
    }
}

// 总结：
//1.解决此类问题，最好是画图，可以用一个数量级比较小的实例来做实例，在已知递推关系式后，刻画 dp 数组，注意数量级比较小的话可以画出 dp 表的内容，特别是注意数组大小和初始化问题
//2.比如此题的两个子串的长度分别是 6 和 9 ，刻画的数组一二维长度分别应该是 7 10 ，预留 二维的头列全为0 ，一维的头行全为0
//3.两个难点，建立dp表 和 读表输出 这两个过程
//  而建立dp 表的最重要的 就是理解 dp 表中存储的值所代表的意义
```



**动态规划，就是从全遍历的递归树为出发点，广度优先遍历，在遍历完每一层之 后对每层结果进行合并（结果相同的）或舍弃（已经超出限制条件的），确保下一层遍历 的数量不会超过限定条件数完W，通过这个操作达到大大减少不必要遍历的目的。 在空间复杂度优化上，通过在计算中只保留最优结果的目的重复利用内存空间。**

## 四种算法思想比较

四种算法思想，贪心、分治、回溯和动态规划

那贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类，因为它跟其他三个都不大一样。为什么这么说呢？前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。 回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。

尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。

贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。 其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。
