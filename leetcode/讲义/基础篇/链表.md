# 链表概念

**链表并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用**

链表又分为四种：

1. 单链表
2. 循环链表
3. 双向链表
4. 循环双向链表

**链表的插入、删除和查询操作**

在链表中插入或者删除一个数据，**我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的**。所以，在链表中插 入和删除一个数据是非常快速的。**但是仅仅是因为不需要维护数据的连续性，在单单进行数据删除的操作的时间复杂度的是 O(1) ，但是想要找到这个数据也是需要遍历的，遍历到的时间复杂度依旧为 O(n)**

> 链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接 计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度

**循环链表**

循环链表仅仅是在单链表的基础上将末位元素的指针由指向 NULL 转换 指向头结点，产生一个循环的效果，在解决[约瑟父问题](https://blog.csdn.net/wenhai_zh/article/details/9620847)上，循环链表十分合适

> 建议查看一下 约瑟夫问题 的链接，里面有关于如何实现链表的建立代码和实际应用
>
> 注意到答主写错了 ，在进行 link-process 函数中，遍历到起始报数位时，进行报数遍历时，截止位 应该是 m-1 不是 m

**双向链表**

双向链表也是在单链表的基础上进行修改，在每个结点上除了 next 指针，另外添加了 prev 指针，用来指向此节点的上一个节点

> 正是因为在每个节点上都添加了一个指针，所以双向链表相对于单链表要占用更多的内存

有了前驱指针，那么更加灵活，可以实现双向遍历，双向链表的应用在哪呢，我们针对 删除 操作进行分析

在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：

1. 删除结点中“值等于某个给定值”的结点； 
2. 删除给定指针指向的结点。

针对第一种情况，无论是单链表还是双向链表，都是需要先循环遍历到这个指针然后再执行删除操作，合计时间复杂度都为O(n)

而第二种情况下，我们想要实现删除的操作，我们需要知道 这个节点的 前驱节点的 引用，只有知道前驱节点的才可以进行删除操作（比如说将这个指针的前驱节点直接指向当前节点的后继节点，那么就实现了删除操作），如果是单链表的话，那么还是需要进行，遍历，当执行到 p->next = q 时，就能得到前驱节点 p 。而如果是双向链表的话， 因为当前节点保存了前驱节点的引用，所以不用进行遍历，可以直接进行删除操作，时间复杂度为O(1)

> **双向链表相对于单链表的特点，用空间换取时间**

**循环双向链表**

循环双向链表也就是在双向链表的基础上将尾节点指向头结点

**数组与链表的区别**

两者的区别不仅仅在于删除和插入操作的时间复杂度，更大的区别在于，数组使用的是连续的内存空间，一经声明就需要占用整块的连续内存空间，并且大小是固定的，无后续无法修改，内存过小，只能再申请一个更大的内存空间。而链表本身没有大小的限制，天然的支持动态扩容

链表在内存相关问题上与数组也有区别，链表在存储本身数据的同时，还需要维护本身节点的指针，如果数据量过大，内存消耗较大。另外链表在进行频繁的插入和删除操作时，还会导致频繁的内存申请和释放，容易造成内存碎片

所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组 还是链表。



**链表代码的书写**

关于链表还有一个难点，如何来书写链表相关操作的代码

**将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中 存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。**

> 代码的正确解读方式：
>
> `p->next=q `， p 结点 中的 next 指针存储了 q 结点的内存地址。q 表示的变量现在 改为 p-next 了，也就现在 变为了 p 的下一个指向
>
> `p->next=p->next->next `  ，p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址， p->next->next 位置表示的变量现在改为了 p->next ，也就是 p 的下下个节点现在是 p 的下个节点了
>
> **也就是在理解概念意思时，从左边往右度，左边存储了右边的数据，在理解指针操作上，左边的数据被右边的数据覆盖了，也就是等式左边的指针指向的原始数据会被丢失，内容会改为右边的数据，而右边的数据没有被丢失，只是更改了名字（引用名字）**

比如我们想要在 p 指针后面插入一个结点，如下操作会 导致 操作失败

```c
p->next = x; // 将 p 的 next 指针指向 x 结点；
x->next = p->next; // 将 x 的结点的 next 指针指向 b 结点；
```

第一步操作，先将左边的 数据给覆盖掉 了 ，也就是无法再访问到 原来的 p->next 。所以更不可能完成插入操作了 。第二步操作相当于将 为 `x->next = x`	 

正确的代码

```c
x->next = p->next // 先存储原始的指向数据
p->next = x // 再覆盖掉原始的数据
```

**针对删除操作**

如果是普通结点的删除

```c
p->next = p->next->next
```

**针对头节点的特殊处理**

```js
// 如果是一个空链表,插入节点
if (head == null) {
	head = new_node
}

// 如果要删除的是链表最后一个结点，也就是头结点
if (head->next == null) {
	head = null
}
```

**哨兵节点**

由于头结点的特殊性，我们在书写代码的时候特定因为头结点而进行特殊性的代码处理，这样代码显得不是很简洁，我们引入哨兵节点这个概念，也就是 head 头结点，不存储数据，存储的内容是 NULL ，而 head 的指针 指向第二个节点，第二个节点开始存储实际的数据。只需要在设计链表和构建链表的时候，将这一特点设计加入即可，那么就可以使用通用代码来实现所有节点的插入和删除操作

```C
head -> data = NULL
head -> next = q
q -> data = firstValue
q -> next = NULL
    
// 删除节点
p -> next = p -> next -> next
    
// 插入节点
x -> next = p -> next
p -> next = x
```





**应该熟练的手写以下链表代码**

1. 单链表反转
2. 链表中环的检测
3. 两个有序的链表合并
4. 删除链表倒数第 n 个结点
5. 求链表的中间结点



# 跳表概念

**跳表的设计就是为了优化链表查询某个数据的这个时间消耗**

跳表是一种动态数据结构，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树（Red-black tree）。**链表加多级索引的结构，就是跳表**

> Redis 中的有序集合（Sorted Set）就是用跳表来实现的

原始的单链表时，想要访问到某个数据上，只能从头到尾遍历链表，查找效率很低，而跳表的的原理就是在原始的单链表上 建立 一级一级的 索引。每两个节点或者多个节点 提取一个节点到上一级，我们把抽出来的那一级叫作 索引 或 索引层，

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200810000135892.png)

>  down 表示下级的索引指针

**跳表是如何实现查找的**？

先在最上层索引进行查找遍历，在属于的范围内通过 down 指针指向下级节点，再在下级节点的索引层接着遍历，通过 down 指针继续进入下层，直到到原始链表，遍历找到节点

**如果一个 长度为 n  的原始链表，那么他需要构建多少层 索引层？**

每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结 点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就 是 n/8，依次类推，也就是说，第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k 级索引结点的个数就是 n/(2^k^ )。

假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n / (2^h^) = 2， 从而求得 h = log~2~n - 1。如果包含原始链表这一层，整个跳表的高度就是 log~2~n。我们在跳 表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。

那这个 m 的值是多少呢？按照前面这种索引结构，我们每一级索引都最多只需要遍历 3 个 结点，也就是说 m = 3 ，（可以通过举例论证） 。**所以在跳表中查询任意数据的时间复杂度就是 O(logn)**

> **两个重要思想：**
>
> 1. **升维：**（**这个查找的时间复杂度跟二分查找是一样的，将一维问题升为二维问题。换句话说，我们其实是基于单链表实现了二分查找**）
> 2. **空间换时间：** （**这种查询效率的提升，前提 是建立了很多级索引，也就是通过空间来换取时间的操作**）

**跳表的空间复杂度分析**

跳表的空间复杂度问题在于 为各个索引而开辟的空间，我们来进行分析

假设原始链表大小为 n，那第一级索引大约 有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到 剩下 4 个结点，2 个节点。如果我们把每层索引的结点数写出来，就是一个等比数列。` n/2+n/4+n/8…+8+4+2 = n-2 `。所以，**跳表的空间复杂度是 O(n)**。**也就是说，如果将包含 n 个结点的单链表构造成跳表，我们需要额外再用接近 n 个 结点的存储空间。**

可以进行优化，比如说 每 三个节点 提升一个节点，那么进行分析的结果是  `n/3+n/9+n/27+…+9+3+1 = n/2`。尽管 空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半 的索引结点存储空间

> 实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我 们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能 是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象 比索引结点大很多时，那索引占用的额外空间就可以忽略了。

**实现高效的动态插入和删除**

跳表 这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操 作的时间复杂度也是 O(logn)。

由于 插入和删除操作 本身时间复杂度为 O(1) ，关键优化的地方在于查询到这个 元素，因为跳表的实现，所以查询到的时间为 O(logn) ,所以整体时间复杂度为 O(logN)

删除操作中，因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所 以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果我们用的是双向链表，就不需要考虑这个问题了。

**跳表的动态更新**

当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点 之间数据非常多的情况。极端情况下，跳表还会退化成单链表。作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是 说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插 入、删除操作性能下降。

> 如果你了解红黑树、AVL 树这样平衡二叉树，你就知道它们是通过左右旋的方式保持左右 子树的大小平衡（如果不了解也没关系，我们后面会讲），**而跳表是通过随机函数来维护前 面提到的“平衡性”。**随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不 至于性能过度退化

当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何 选择加入哪些索引层呢？ 我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就 **将这个结点添加到第一级到第 K 级这 K 级索引中。**

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200810002218674.png)

> 也就说 跳表在进行删除和插入操作的时候，维护成本较高
