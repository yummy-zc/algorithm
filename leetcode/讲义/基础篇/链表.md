# 链表概念

**链表并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用**

链表又分为四种：

1. 单链表
2. 循环链表
3. 双向链表
4. 循环双向链表

**链表的插入、删除和查询操作**

在链表中插入或者删除一个数据，**我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的**。所以，在链表中插 入和删除一个数据是非常快速的。**但是仅仅是因为不需要维护数据的连续性，在单单进行数据删除的操作的时间复杂度的是 O(1) ，但是想要找到这个数据也是需要遍历的，遍历到的时间复杂度依旧为 O(n)**

> 链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接 计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度

## 链表的种类

### **循环链表**

循环链表仅仅是在单链表的基础上将末位元素的指针由指向 NULL 转换 指向头结点，产生一个循环的效果，在解决[约瑟父问题](https://blog.csdn.net/wenhai_zh/article/details/9620847)上，循环链表十分合适

> 建议查看一下 约瑟夫问题 的链接，里面有关于如何实现链表的建立代码和实际应用
>
> 注意到答主写错了 ，在进行 link-process 函数中，遍历到起始报数位时，进行报数遍历时，截止位 应该是 m-1 不是 m

### **双向链表**

双向链表也是在单链表的基础上进行修改，在每个结点上除了 next 指针，另外添加了 prev 指针，用来指向此节点的上一个节点

> 正是因为在每个节点上都添加了一个指针，所以双向链表相对于单链表要占用更多的内存

有了前驱指针，那么更加灵活，可以实现双向遍历，双向链表的应用在哪呢，我们针对 删除 操作进行分析

在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：

1. 删除结点中“值等于某个给定值”的结点； 
2. 删除给定指针指向的结点。

针对第一种情况，无论是单链表还是双向链表，都是需要先循环遍历到这个指针然后再执行删除操作，合计时间复杂度都为O(n)

而第二种情况下，我们想要实现删除的操作，我们需要知道 这个节点的 前驱节点的 引用，只有知道前驱节点的才可以进行删除操作（比如说将这个指针的前驱节点直接指向当前节点的后继节点，那么就实现了删除操作），如果是单链表的话，那么还是需要进行，遍历，当执行到 p->next = q 时，就能得到前驱节点 p 。而如果是双向链表的话， 因为当前节点保存了前驱节点的引用，所以不用进行遍历，可以直接进行删除操作，时间复杂度为O(1)

> **双向链表相对于单链表的特点，用空间换取时间**

### **循环双向链表**

循环双向链表也就是在双向链表的基础上将尾节点指向头结点

## **数组与链表的区别**

两者的区别不仅仅在于删除和插入操作的时间复杂度，更大的区别在于，数组使用的是连续的内存空间，一经声明就需要占用整块的连续内存空间，并且大小是固定的，无后续无法修改，内存过小，只能再申请一个更大的内存空间。而链表本身没有大小的限制，天然的支持动态扩容

链表在内存相关问题上与数组也有区别，链表在存储本身数据的同时，还需要维护本身节点的指针，如果数据量过大，内存消耗较大。另外链表在进行频繁的插入和删除操作时，还会导致频繁的内存申请和释放，容易造成内存碎片

所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组 还是链表。

**链表代码的书写**

关于链表还有一个难点，如何来书写链表相关操作的代码

**将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中 存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。**

> 代码的正确解读方式：
>
> `p->next=q `， p 结点 中的 next 指针存储了 q 结点的内存地址。q 表示的变量现在 改为 p-next 了，也就现在 变为了 p 的下一个指向
>
> `p->next=p->next->next `  ，p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址， p->next->next 位置表示的变量现在改为了 p->next ，也就是 p 的下下个节点现在是 p 的下个节点了
>
> **也就是在理解概念意思时，从左边往右度，左边存储了右边的数据，在理解指针操作上，左边的数据被右边的数据覆盖了，也就是等式左边的指针指向的原始数据会被丢失，内容会改为右边的数据，而右边的数据没有被丢失，只是更改了名字（引用名字）**

比如我们想要在 p 指针后面插入一个结点，如下操作会 导致 操作失败

```c
p->next = x; // 将 p 的 next 指针指向 x 结点；
x->next = p->next; // 将 x 的结点的 next 指针指向 b 结点；
```

第一步操作，先将左边的 数据给覆盖掉 了 ，也就是无法再访问到 原来的 p->next 。所以更不可能完成插入操作了 。第二步操作相当于将 为 `x->next = x`	 

正确的代码

```c
x->next = p->next // 先存储原始的指向数据
p->next = x // 再覆盖掉原始的数据
```

**针对删除操作**

如果是普通结点的删除

```c
p->next = p->next->next
```

**针对头节点的特殊处理**

```js
// 如果是一个空链表,插入节点
if (head == null) {
	head = new_node
}

// 如果要删除的是链表最后一个结点，也就是头结点
if (head->next == null) {
	head = null
}
```

**哨兵节点**

由于头结点的特殊性，我们在书写代码的时候特定因为头结点而进行特殊性的代码处理，这样代码显得不是很简洁，我们引入哨兵节点这个概念，也就是 head 头结点，不存储数据，存储的内容是 NULL ，而 head 的指针 指向第二个节点，第二个节点开始存储实际的数据。只需要在设计链表和构建链表的时候，将这一特点设计加入即可，那么就可以使用通用代码来实现所有节点的插入和删除操作

```C
head -> data = NULL
head -> next = q
q -> data = firstValue
q -> next = NULL
    
// 删除节点
p -> next = p -> next -> next
    
// 插入节点
x -> next = p -> next
p -> next = x
```

## **应该熟练的手写以下链表代码**

1. 单链表反转
2. 链表中环的检测
3. 两个有序的链表合并
4. 删除链表倒数第 n 个结点
5. 求链表的中间结点



# 跳表概念

**跳表的设计就是为了优化链表查询某个数据的这个时间消耗**

跳表是一种动态数据结构，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树（Red-black tree）。**链表加多级索引的结构，就是跳表**

> Redis 中的有序集合（Sorted Set）就是用跳表来实现的

原始的单链表时，想要访问到某个数据上，只能从头到尾遍历链表，查找效率很低，而跳表的的原理就是在原始的单链表上 建立 一级一级的 索引。每两个节点或者多个节点 提取一个节点到上一级，我们把抽出来的那一级叫作 索引 或 索引层，

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200810000135892.png)

>  down 表示下级的索引指针

**跳表是如何实现查找的**？

先在最上层索引进行查找遍历，在属于的范围内通过 down 指针指向下级节点，再在下级节点的索引层接着遍历，通过 down 指针继续进入下层，直到到原始链表，遍历找到节点

**如果一个 长度为 n  的原始链表，那么他需要构建多少层 索引层？**

每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结 点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就 是 n/8，依次类推，也就是说，第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k 级索引结点的个数就是 n/(2^k^ )。

假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n / (2^h^) = 2， 从而求得 h = log~2~n - 1。如果包含原始链表这一层，整个跳表的高度就是 log~2~n。我们在跳 表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。

那这个 m 的值是多少呢？按照前面这种索引结构，我们每一级索引都最多只需要遍历 3 个 结点，也就是说 m = 3 ，（可以通过举例论证） 。**所以在跳表中查询任意数据的时间复杂度就是 O(logn)**

> **两个重要思想：**
>
> 1. **升维：**（**这个查找的时间复杂度跟二分查找是一样的，将一维问题升为二维问题。换句话说，我们其实是基于单链表实现了二分查找**）
> 2. **空间换时间：** （**这种查询效率的提升，前提 是建立了很多级索引，也就是通过空间来换取时间的操作**）

**跳表的空间复杂度分析**

跳表的空间复杂度问题在于 为各个索引而开辟的空间，我们来进行分析

假设原始链表大小为 n，那第一级索引大约 有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到 剩下 4 个结点，2 个节点。如果我们把每层索引的结点数写出来，就是一个等比数列。` n/2+n/4+n/8…+8+4+2 = n-2 `。所以，**跳表的空间复杂度是 O(n)**。**也就是说，如果将包含 n 个结点的单链表构造成跳表，我们需要额外再用接近 n 个 结点的存储空间。**

可以进行优化，比如说 每 三个节点 提升一个节点，那么进行分析的结果是  `n/3+n/9+n/27+…+9+3+1 = n/2`。尽管 空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半 的索引结点存储空间

> 实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我 们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能 是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象 比索引结点大很多时，那索引占用的额外空间就可以忽略了。

**实现高效的动态插入和删除**

跳表 这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操 作的时间复杂度也是 O(logn)。

由于 插入和删除操作 本身时间复杂度为 O(1) ，关键优化的地方在于查询到这个 元素，因为跳表的实现，所以查询到的时间为 O(logn) ,所以整体时间复杂度为 O(logN)

删除操作中，因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所 以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果我们用的是双向链表，就不需要考虑这个问题了。

**跳表的动态更新**

当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点 之间数据非常多的情况。极端情况下，跳表还会退化成单链表。作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是 说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插 入、删除操作性能下降。

> 如果你了解红黑树、AVL 树这样平衡二叉树，你就知道它们是通过左右旋的方式保持左右 子树的大小平衡（如果不了解也没关系，我们后面会讲），**而跳表是通过随机函数来维护前 面提到的“平衡性”。**随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不 至于性能过度退化

当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何 选择加入哪些索引层呢？ 我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就 **将这个结点添加到第一级到第 K 级这 K 级索引中。**

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200810002218674.png)

> 也就说 跳表在进行删除和插入操作的时候，维护成本较高



# 链表的基本操作

### 插入

插入只需要考虑要插入位置前驱节点和后继节点（双向链表的情况下需要更新后继节点）即可，其他节点不受影响，因此在给定指针的情况下插入的操作时间复杂度为`O(1)`

伪代码：

```
temp = 待插入位置的前驱节点.next
待插入位置的前驱节点.next = 待插入指针
待插入指针.next = temp
```

如果没有给定指针，我们需要先遍历找到节点，因此最坏情况下时间复杂度为 `O(N)`

### 删除

只需要将需要删除的节点的前驱指针的 next 指针修正为其下下个节点即可，注意考虑**边界条件**。

伪代码：

```
待删除位置的前驱节点.next = 待删除位置的前驱节点.next.next
```

### 遍历

伪代码：

```
当前指针 =  头指针
while 当前指针不为空 {
   print(当前节点)
   当前指针 = 当前指针.next
}
```

# 常见题型

### 题型一：反转链表

1. **将某个链表或链表片段进行反转**
2. **在 O(n) 时间, O(1) 空间复杂度下逆序读取链表的某个值**
3. **将某个链表按 K 个一组进行反转**

[![img](https://camo.githubusercontent.com/cd0da596ae96269873afdb17211ddb0aa668cdc770d06456de723d0069d6d1a8/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303753385a496c6c79316766696835776d39767a6a3331656d3038306162782e6a7067)](https://camo.githubusercontent.com/cd0da596ae96269873afdb17211ddb0aa668cdc770d06456de723d0069d6d1a8/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303753385a496c6c79316766696835776d39767a6a3331656d3038306162782e6a7067) 

##### 将某个链表或链表片段进行反转

```JS
let cur = head;
let pre = null;
while (cur) {
  const next = cur.next;
  cur.next = pre;
  pre = cur;
  cur = next;
}
return pre;
```

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithm反转链表.png)

**复杂度分析**

- 时间复杂度：`O(N)`
- 空间复杂度：`O(1)`

**例题**

- [x] [206.反转链表](/leetcode/题目/基础篇/链表/206.反转链表.md)
- [ ] [92.反转链表二](/leetcode/题目/基础篇/链表/92.反转链表二.md)

### 题型二：合并链表

1. **将两条有序或无序的链表合并成一条有序链表**
2. **将 k 条有序链表合并成一条有序链表**

[![img](https://camo.githubusercontent.com/b284c9eb107dd4cd5fb386a23829b12269ee45cb507eca7949e43e19f4220ada/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303753385a496c6c79316766696836746c7369636a333130653062777768312e6a7067)](https://camo.githubusercontent.com/b284c9eb107dd4cd5fb386a23829b12269ee45cb507eca7949e43e19f4220ada/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303753385a496c6c79316766696836746c7369636a333130653062777768312e6a7067) 

构建一个新返回头节点，即新建一个链表来返回，三个指针按照条件来移动

伪代码:

```JS
ans = new Node(-1) // ans 为需要返回的头节点
cur = ans
// l1和l2分别为需要合并的两个链表的头节点
while l1 和 l2 都不为空
    cur.next = min(l1.val, l2.val)
    更新较小的指针，往后移动一位
if l1 == null
   cur.next = l2
if l2 == null
   cur.next = l1
return ans.next
```

JS 代码参考:

```JS 
let ans = (now = new ListNode(0));
while (l1 !== null && l2 !== null) {
  if (l1.val < l2.val) {
    now.next = l1;
    l1 = l1.next;
  } else {
    now.next = l2;
    l2 = l2.next;
  }
  now = now.next;
}

if (l1 === null) {
  now.next = l2;
} else {
  now.next = l1;
}
return ans.next;
```

**复杂度分析**

- 时间复杂度：`O(N)`
- 空间复杂度：`O(1)`

**例题**

- [x] [21.合并两个有序链表](/leetcode/题目/基础篇/链表/21.合并两个有序链表.md)

### 题型三：相交或环形链表

1. **判断某条链表是否存在环**
2. **获取某条链表环的大小**
3. **获取某两条链表的相交节点**

[![img](https://camo.githubusercontent.com/bb7b6ca6728529c5b80d07b8d9f9bfb7bd30273b9c176dce711061d258fd68ce/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303753385a496c6c79316766696861786c6d71656a33313771306c673431772e6a7067)](https://camo.githubusercontent.com/bb7b6ca6728529c5b80d07b8d9f9bfb7bd30273b9c176dce711061d258fd68ce/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303753385a496c6c79316766696861786c6d71656a33313771306c673431772e6a7067) 

##### 求环形链表求环的起点

解法一：哈希法

- 遍历整个链表,同时将每个节点都插入哈希表,
- 如果当前节点在哈希表中不存在,继续遍历,
- 如果存在,那么当前节点就是环的入口节点

伪代码:

```JS
data = new Set() // 声明哈希表
while head不为空{
  if 当前节点在哈希表中存在{
    return head // 当前节点就是环的入口节点
  } else {
    将当前节点插入哈希表
  }
  head指针后移
}
return null // 环不存在
```

JS 代码参考:

```JS
let data = new Set();
while (head) {
  if (data.has(head)) {
    return head;
  } else {
    data.add(head);
  }
  head = head.next;
}
return null;
```

**复杂度分析**

- 时间复杂度：`O(N)`
- 空间复杂度：`O(N)`

解法二：快慢指针法

1. 定义一个 fast 指针,每次**前进两步**,一个 slow 指针,每次**前进一步**
2. 当两个指针相遇时
   1. 将 fast 指针指向链表头部,同时 fast 指针每次只**前进一步**
   2. slow 指针继续前进,每次**前进一步**
3. 当两个指针再次相遇时,当前节点就是环的入口

**复杂度分析**

- 时间复杂度：`O(N)`
- 空间复杂度：`O(1)`

详细解析：[142.环形链表二](/leetcode/题目/基础篇/链表/142.环形链表二.md)

##### **获取某两条链表的相交节点**

解法一：哈希法

- 有 A, B 这两条链表, 先遍历其中一个，比如 A 链表, 并将 A 中的所有节点存入哈希表。
- 遍历 B 链表,检查节点是否在哈希表中, 第一个存在的就是相交节点

伪代码:

```JS
data = new Set() // 存放A链表的所有节点的地址

while A不为空{
  哈希表中添加A链表当前节点
  A指针向后移动
}

while B不为空{
  if 如果哈希表中含有B链表当前节点
    return B
  B指针向后移动
}

return null // 两条链表没有相交点
```

JS 代码参考:

```JS
let data = new Set();
while (A !== null) {
  data.add(A);
  A = A.next;
}
while (B !== null) {
  if (data.has(B)) return B;
  B = B.next;
}
return null;
```

**复杂度分析**

- 时间复杂度：`O(N)`
- 空间复杂度：`O(N)`

解法二：双指针

- 例如使用 a, b 两个指针分别指向 A, B 这两条链表, 两个指针相同的速度向后移动,
- 当 a 到达链表的尾部时,重定位到链表 B 的头结点
- 当 b 到达链表的尾部时,重定位到链表 A 的头结点。
- a, b 指针相遇的点为相交的起始节点，否则没有相交点

伪代码:

```JS
a = headA
b = headB
while a,b指针不相等时 {
    if a指针为空时
      a指针重定位到链表 B的头结点
    else
      a指针向后移动一位
    if b指针为空时
      b指针重定位到链表 A的头结点
    else
      b指针向后移动一位
}
return a
```

JS 代码参考:

```JS
var getIntersectionNode = function (headA, headB) {
  let a = headA,
    b = headB;
  while (a != b) {
    a = a === null ? headB : a.next;
    b = b === null ? headA : b.next;
  }
  return a;
};
```

**复杂度分析**

- 时间复杂度：`O(N)`
- 空间复杂度：`O(1)`

### **题型四：设计题（综合）**

要求设计一种数据结构，可以在指定的时间或空间复杂度下完成 XX 操作，这种题目的套路就是**牢记所有基本数据结构的基本操作以及其复杂度**。分析算法的瓶颈，并辅以恰当的数据结构进行优化

- [ ] [146. LRU 缓存机制](https://github.com/azl397985856/leetcode/blob/master/problems/146.lru-cache.md)

**例题**

```
设计一个算法支持以下操作:

获取数据 get 和 写入数据 put 。

获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。

写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

在 O(1) 时间复杂度内完成这两种操作
```

思路:

1. 确定需要使用的数据结构

   1. 根据题目要求,存储的数据需要保证顺序关系(逻辑层面) ===> 使用数组,链表等保证循序关系

   2. 同时需要对数据进行频繁的增删, 时间复杂度 O(1) ==> 使用链表等

   3. 对数据进行读取时, 时间复杂度 O(1) ===> 使用哈希表

      最终采取双向链表 + 哈希表

      > 1. 双向链表按最后一次访问的时间的顺序进行排列, 链表头部为最近访问的节点
      > 2. 哈希表,以关键字为键,以链表节点的地址为值

2. put 操作

   通过哈希表, 查看传入的关键字对应的链表节点, 是否存在

   1. 如果存在,
      1. 将该链表节点的值更新
      2. 将该该链表节点调整至链表头部
   2. 如果不存在
      1. 如果链表容量未满,
         1. 新生成节点,
         2. 将该节点位置调整至链表头部
      2. 如果链表容量已满
         1. 删除尾部节点
         2. 新生成节点
         3. 将该节点位置调整至链表头部
      3. 将新生成的节点，按关键字为键，节点地址为值插入哈希表

3. get 操作

   通过哈希表, 查看传入的关键字对应的链表节点, 是否存在

   1. 节点存在
      1. 将该节点位置调整至链表头部
      2. 返回该节点的值
   2. 节点不存在, 返回 null

伪代码:

```JS
var LRUCache = function(capacity) {
	保存一个该数据结构的最大容量
	生成一个双向链表,同时保存该链表的头结点与尾节点
	生成一个哈希表
};

function get (key) {
	if 哈希表中存在该关键字 {
		根据哈希表获取该链表节点
		将该节点放置于链表头部
		return 链表节点的值
	} else {
		  return -1
	}
};

function put (key, value) {
    if 哈希表中存在该关键字 {
		根据哈希表获取该链表节点
		将该链表节点的值更新
		将该节点放置于链表头部
	} else {
		if 容量已满 {
			删除链表尾部的节点
			新生成一个节点
			将该节点放置于链表头部
		} else {
			新生成一个节点
			将该节点放置于链表头部
		}
	}
};
```

JS 代码参考:

```JS
function ListNode(key, val) {
  this.key = key;
  this.val = val;
  this.pre = this.next = null;
}

var LRUCache = function (capacity) {
  this.capacity = capacity;
  this.size = 0;
  this.data = {};
  // 构建双向链表
  this.head = new ListNode();
  this.tail = new ListNode();
  this.head.next = this.tail;
  this.tail.pre = this.head;
}

function get(key) {
  if (this.data[key] !== undefined) {
    let node = this.data[key];
    this.removeNode(node);
    this.appendHead(node);
    return node.val;
  } else {
    return -1
  }
}

function put(key ,value) {
  let node;
  if (this.data[key] !== undefined) {
    node = this.data[key];
    this.removeNode(node);
    node.val = value;
  } else {
    node = new ListNode(key, val) {
      this.data[key] = node;
      if (this.size < this.capacity) {
        this.size++;
      } else {
        key = this.removeTail();
        delete this.data[key];
      }
    }
  }
  this.appendHead(node);
}

function removeNode(node) {
  let preNode = node.pre;
  nextNode = node.next;
  preNode.next = nextNode;
  nextNode.pre = preNode;
}

function appendHead(node) {
  let firstNode = this.head.next;
  this.head.next.node;
  node.pre = this.head;
  node.next = firstNode;
  firstNode.pre = node;
}

function removeTail() {
  let key = this.tail.pre.key;
  this.removeNode(this.tail.pre);
  return key
}
```

哈希表里存储的是以 key 为 键名 node 类型的节点

> 在碰到设计题这种对数据结构的设计能力要求较高时，一般会需要使用到 2-3 种数据结构，这时要根据具体的使用场景去分析，如何将各种数据结构的优势结合到一起，慢慢大家写的多了，碰到设计题就有了固定的思维模式，ac 也就水到渠成。

题目推荐

- [ ] [82.删除排序链表中的重复元素二](/leetcode/题目/基础篇/指针/82.删除排序链表中的重复元素二.md)
- [ ] [83.删除排序链表中的重复元素](/leetcode/题目/基础篇/指针/83.删除排序链表中的重复元素.md)
- [ ] 循环链表删除节点 [约瑟夫环问题](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/tong-su-yi-dong-mo-yun-suan-mo-ni-python3-by-azl39/)
- [ ] 双向链表 [146. LRU 缓存机制](https://github.com/azl397985856/leetcode/blob/master/problems/146.lru-cache.md)
- [ ] [86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)
- [ ] [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)
- [ ] [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)
- [ ] [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)
- [ ] [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

