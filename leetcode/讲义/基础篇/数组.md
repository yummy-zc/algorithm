# 数组

## 基础概念

数组的定义：数 组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

JavaScript是动态语言，数组可以存储不同类型的数据，数组可以保存不同类型的值，这是因为其内部做了处理。对于 V8 引擎来说， 它将数据类型分为基本类型和引用类型，**基本类型直接存储值在栈上，而引用类型存储指针在栈上**，真正的内容存到堆上。因此不同的数据类型也可以保持同样的长度。

为什么静态语言要求存储同样类型的数据类型？为了支持随机访问，可以用**基址 + 偏移量**来定位任意一个元素

### 线性表

> 线性表：数据像排成一条线一样的结构，每个线性表上的数据只有前和后两个方向，除了数组，链表、栈、队列都是线性表结构
>
> 非线性表：二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

#### **连续的内存空间和相同类型的数据**

> 连续的内存空间和相同类型的数据，正是因为这个特点而对应出了 随机访问 的特性。同时也因为这个特点带来弊端，因为要保持连续性，不便于插入和删除
>
> **在进行随机访问时，由于是连续的内容空间，同时数据类型相同（每个数据大小也是相同的），那么在进行随机访问时，就非常方便，可以利用计算公式来访问`a[k]_address = base_address + (k-1)*type_size`**
>
> **所以数组这种结构，适用于数据已经确定好了，后续不用修改，仅用来快速查询的**

> **注意！！：**
>
> 我们常说  **数组适合查找，查找时间复杂度为 O(1)**，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表 述应该是，**数组支持随机访问，==根据下标随机访问==的时间复杂度为 O(1)。而哈希表查询是O(1)**

#### **关于数组插入操作的相关问题**

数组中插入是不方便的，但是我们需要仔细的来分析一下，假设在数组中插入数据，数组大小为 n ，数据在数组每个位置插入的概率都是相同的，最坏插入的时间复杂度为 O(n) （即最后一位），**平均复杂度为  (1+2+ …n)/n=O(n)**。所以数组中插入数据总体效果不是很好

如果我们只是把数组当做一个存储数据的集合，无序，那么在想要插入的位置插入数据，可以先将在这个位置的数据移动到最后一位，然后再将数据插入到这个位置，时间复杂度也为 O(1），这在快速排序中有使用到这个思想

如果非要在数组中删除一个元素话，那么也不能直接删除这个元素，只有将数组的最后一个元素的值覆盖掉要删除的元素，然后删除掉最后一个元素，从而实现删除的效果，无论什么语言，在数组这种结构中，使用内置方法直接删除某个元素都是会将数组的进行重新排序，性能不好，最好的方式就是数组仅仅用来查询值，而不进行修改

#### **关于数组删除操作的相关问题**

和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的 数据，则最坏情况时间复杂度为 O(n)；**平均情况时间复杂度也为 O(n)。**

实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们**将多次 删除操作 集中在一起执行**，删除的效率会提高很多，我们可以先记录下已经删除的数据。 每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。 **这也是JVM 标记清除垃圾回收算法的核心思想**

#### **数组编号为什么不从1开始而从0开始**

为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？

**从CPU执行指令的效率上来看**

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就 表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式：

`a[k]_address = base_address + k * type_size`

但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：

`a[k]_address = base_address + (k-1)*type_size`

对比两个公式，我们不难发现，从 1 开始编号，**每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令**。 数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号， 而不是从 1 开始。

**从历史原因来看**

C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都**效仿了 C 语言**，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了 从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。

> 二维数组访问的地址计算公式（假设二维数组的维度为m * n）：
>
> `a[i][j]_address = base_address + (i * n + j) * type_size`

## 题目推荐

- 28
- 75
- 380
- 59
- 859







# 暂时存放

## 基础操作

### 数组

|                数组                 |             Java（ArrayList）              |                 JS                  |
| :---------------------------------: | :----------------------------------------: | :---------------------------------: |
|          修改指定位置的值           |             set(index，value)              |         arr[index] = value          |
|       在指定位置添加值(插入)        |              add(index,value)              |           splice(),fill()           |
|            访问指定元素             |                 get(index)                 |             arr[index]              |
|              删除元素               |               remove(index)                |              splice()               |
|              计算大小               |                   size()                   |             arr.length              |
|          特定位置添加元素           |                     无                     |          push()、unshift()          |
|          特定位置删除元素           |                     无                     |           pop()、shift()            |
|         检测是否存在这个数          | contains(),indexOf(),Arrays.binarySearch() | indexOf(),includes(),some(),find()  |
|              复制数组               |    Arrays.copyOf(),Arrays.copyOfRange()    |               slice()               |
|                排序                 |              Arrays.sort(arr)              |          reverse(),sort()           |
|           数组之间的组合            |             System.arraycopy()             |          concat(),splice()          |
|          数组转化为字符串           |                                            |              join("")               |
|                                     |                                            |                                     |
|              遍历数组               |                for-Each(:)                 |   forEach(),map(),for...of('of')    |
|           判断是否为数组            |                 isArray()                  |              isArray()              |
|          检测各个数组元素           |                                            |           every(),some()            |
|              过滤元素               |                                            |              filter()               |
|          查询元素值的索引           |                                            | indexOf(),lastIndexOf(),findIndex() |
|        将其他类型转化为数组         |                                            | from(arrayLike[, mapFn[, thisArg])  |
|      返回 Array Iterator 对象       |                                            |      keys(),entries(),values()      |
|                正常                 |                     .                      |                                     |
| ArrayList String 类型转换为str数组  |     arrList.toArray(new String[size])      |                                     |
| ArrayList Integer 类型转换为int数组 |              for循环遍历赋值               |                                     |
|       数组转换为集合ArrayList       |             Arrays.asList(arr)             |                                     |
|                                     |                                            |                                     |
|                                     |                                            |                                     |
|                                     |                                            |                                     |

### 哈希表

|       哈希表       |           Java           |                JS                 |
| :----------------: | :----------------------: | :-------------------------------: |
| 检测是否存在某个值 |   map.contains(value)    |              值做key              |
|     添加键值对     |    map.put(key,value)    |        map.set(key, value)        |
|      访问元素      |       map.get(key)       |        map[]，map.get(key)        |
|     删除键值对     |     map.remove(key)      |          map.delete(key)          |
|    修改某键值对    |  map.replace(key,value)  |        map.set(key, value)        |
|  检测是否存在 key  |   map.containsKey(key)   |           map.has(key)            |
| 检测是否存在 value | map.containsValue(value) |              值做key              |
|     清除哈希表     |       map.clear()        |            map.clear()            |
|  计算哈希表的大小  |        map.size()        |             map.size              |
|      遍历键名      |       map.keySet()       | map.keys() (Iterator对象),key..in |
|      遍历键值      |       map.values()       |    map.values() (Iterator对象)    |
|   返回可迭代对象   |                          |           map.entries()           |
|    遍历 map 表     |         for-Each         |      map.forEach(callback())      |
|    检测是否为空    |      map.isEmpty()       |                                   |
| 将对象转换为哈希表 |                          |   new Map(Object.entries(obj))    |
|                    |                          |                                   |
|                    |                          |                                   |
|                    |                          |                                   |
|                    |                          |                                   |

> 对象与Map不同，对象可以像数组一样下标访问，Map不行

[关于 对象 与 HashMap 的区别](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20210211005628608.png)

### 字符串

|         字符串         |               Java                |                     JS                      |
| :--------------------: | :-------------------------------: | :-----------------------------------------: |
|     获取字符串长度     |           str.length()            |                 str.length                  |
|       截取字符串       |     str.substring(start,end)      |  substring(s,t)，substr(s,length)，slice()  |
|   判断字符串是否相等   |            equals(str)            |               str.equals(str)               |
|  获取字符串中某个字符  |      charAt()，charCodeAt()       |   str[index]，str.charAt()，charCodeAt()    |
|    字符（串）的查找    | indexOf(String s)，lastIndexOf()  | indexOf()，lastIndexOf()，search()，match() |
|      字符串的修改      |        replace(oldS,newS)         |           replace()，replaceAll()           |
|    字符串大小写切换    |   toLowerCase()，toUpperCase()    |        toLowerCase()，toUpperCase()         |
|  字符串转换为字符数组  |           str.split('')           |                str.split('')                |
| 将字符数组转换为字符串 | new String(char[])，toCharArray() |                                             |
|      去掉首尾空格      |              trim()               |                   trim()                    |
|     判断字符串开头     |     startsWith(String prefix)     |               startsWith(str)               |
|     判断字符串结尾     |      endsWith(String suffix)      |                endsWith(str)                |
|    判断是否存在子串    |    contains(str)，indexOf(str)    |                includes(str)                |
|   判断字符串是否为空   |             isEmpty()             |                                             |
|      字符串的连接      |                                   |              str.concat(str2)               |
|                        |                                   |       JS 字符串方法拥有许多数组的方法       |
|    判断两个字符是否    |                ==                 |                     ===                     |

将数组的值累加 ： arr.reduce((a,b) => a + b)



## 基础操作实例

**创建数组**

```JS
1.创建一个规定大小的数组
  let arr = new Array(30) 	// 值都为undefined

2.常规字面量建法
  let arr = [1,2,3,55]

3.Array.of()   // ES6 方法	数组创建，将参数中所有值作为元素形成数组，如果参数为空，则返回一个空数组。
  Array.of(1, 2, 3, 4); 		// [1, 2, 3, 4] 

4.Array(arr.length).fill(0)
```

```Java
1.声明
  int[] arr
  String[][] str = new String[3][4]

2.初始化
  int[] arr = new int[] {1,2,3,4,5}
  int[] arr = {1,2,3,4}
  int[][]	arr = new int[][] {{1},{2,3},{4},{4,5,6}}

3.多维数组
  int intArray[][] = new int[4][]; //先初始化高维数组为4
  // 逐一初始化低维数组
  intArray[0] = new int[2];
  intArray[1] = new int[1];
  intArray[2] = new int[3];
  intArray[3] = new int[3];

4.创建 ArrayList 对象
  // 一维 数组
  ArrayList<Integer> arr = new ArrayList()
  
  // 二维 数组
  
  List<List<Integer>> arr2 = new ArrayList()
 
  // 动态创建
  new ArrayList<Integer>(Arrays.asList(nums[k], nums[i], nums[j]))
```

JS 可以 通过 arr.length 来动态设定 数组长度， 多余的用 undefined 填充

```JS
arr.length = 5
```

**数组值的删除**

```JS
pop()
let lastValue = arr.pop()  // 删除的数组最后一位值，并且返回这个值
```

```JS
shift()
let fitstValue = arr.shift() 	// 删除数组的第一位值，并且返回这个值
```

**添加值到数组**

```JS
push()
let addValue = arr.push(6)	// 	添加值到数组的最后一位，返回数组长度
```

```JS
unshfit()
let addFirst = arr.unshift(12) // 添加值到数组第一位，返回数组长度
```

**综合操作 splice**

可以实现 数组元素的删除 和 数组元素的添加，默认是以删除为目的

```JS
splice(start[, deleteCount[, item1[, item2[, ...]]]])
// 三个参数：数组的起始位，删除的数组元素的个数，要添加的元素 ，第一个为必须，其他两个可省略
// 返回值：有删除的元素，返回删除的值的组成的数组，没删除的元素，返回空数组

实现数组元素的添加 arr.splice(添加的起始位，0，要添加的数组元素)
arr.splice(0,0,1,2,3,4)			// 添加（插入）元素 1 2 3 4 到数组的第一位

实现数组元素的删除
arr.splice(2,5) 						// 从索引为 2 的起始位开始，删除后面的五个元素 ，返回删除元素组成的元素

实现数组元素的删除与添加 
arr.splice(2,5,9,9,9)			// 先删除五个元素后，添加9，9，9
```

**数组的复制**

```JS
1.slice(start.end) 			// 复制数组，返回新数组，不改变原数组
arr.slice(1,3)				// 从索引值为 1 的元素开始复制（包含1对应的元素），到索引值为 3 的元素截止（不包含3对应的元素）
```

```java
1.Arrays.copyOf() 和 Arrays.copyOfRange
  int[] array = new int[]{3,7,8,2,1,9};
  array2 = Arrays.copyOf(array,3); //新数组的长度为3
  array3 = Arrays.copyOfRange(array,3,5); //复制第三到五个元素

2. System.arrayCopy(Object src,int srcPos,Object dest,int destPos,int length)
    参数：
    src - 源数组。
    srcPos - 源数组中的起始位置。
    dest - 目标数组。
    destPos - 目的地数据中的起始位置。
    length - 要复制的源数组元素的数量。
```

**数组的排序**

```JS
1.reverse()			// 倒置数组，对原数组产生影响，返回一个颠倒后的数组
arr.reverse()


TODO？？？？？
2.sort()			//  按照想要的方式进行排序，改变原数组，由于它取决于具体实现，因此无法保证排序的时间和空间复杂性。
默认没有参数时 arr.sort()	// 按照ASCII码的大小进行排序
接受一个回调函数作为参数，如果返回值为正数的话，按照由小到大的排序，返回为负值，按照由大到小的排序
a.sort(function(a,b)=>{return a - b})			// 按照由小到大的排序
a.sort(function(a,b)=>{return b - a})			// 按照由大到小的排序 
```

```java
1.Arrays.sort()
  int[] array = new int[]{3,7,8,2,1,9};
  Arrays.sort(array);    //全排序
  Arrays.sort(array,2,5);    //2到5排序

2.Arrays.sort(arr, Collections.reverseOrder());  // 倒序排序
	Integer[] ew = { 9, 8, 7, 2, 3, 4, 1, 0, 6, 5 };  // 使用这种方法  数组必须是包装类型
	Arrays.sort(ew, Collections.reverseOrder());  // 倒序排序
```

**数组的元素截取**

```JS
1.slice()					// 分割 指定起始位 与 终止位的数组元素 ，返回一个新的数组
arr.slice(stratIndex,endIndex)
```

**数组之间的组合**

```JS
1.concat()				// 	组合数组，将两个数组组合为一个数组，参数为需要组合的数组，返回一个新数组
arr1.concat(arr2)
```

**将数组转化为字符串**

```JS
join()				// 将数组元素组合为字符串 ,	有参转换和无参转换
let arr = [1,2,3,4,5]

let StringValue = arr.join() 				// "1,2,3,4,5"

let StringValue2 = arr.join() 			//	"12345"
```

**将数组转换为集合**

```java
1.Array.asList()
  List<List<Integer>> res = new ArrayList<>();
  res.add(new ArrayList<Integer>(Arrays.asList(nums[k], nums[i], nums[j])));
```

**遍历数组**

```JS
1.forEach(callback(currentValue [, index [, array]])[, thisArg])			
	// forEach() 方法对数组的每个元素执行一次给定的函数。不会对原数组进行改变，方法返回的是undefined
  // 参数为 一个回调函数和 一个当执行回调函数 callback 时，用作 this 的值（）可省略。
  // 回调函数为必须，参数current为遍历的当前元素的值，index为当前数组元素的索引，array为遍历的这个数组对象本身

  // forEach 方法主要为遍历数组元素，读取数组元素的值做读取操作，方法返回的是undefined，原理上不会对原数组的值进行改变，所以重点在与遍历读取数组元素
  let NumberArr = [1,2,3,4,5]
  let sum = 0

  NumberArr.forEach(element => {
        sum += element
  }

2.map(callback(currentValue [, index [, array]])[, thisArg]) 
	//  参数与 forEach() 方法是一样的，与此方法的重要区别在于会返回新的数组，不会修改原数组，
  // 因为map生成一个新数组，当你不打算使用返回的新数组却使用map是违背设计初衷的，请用forEach或者for-of替代


3.for....of 语句
  // for...of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环
  // 与 forEach方法功能类型，主要也是做读取操作
  const array1 = ['a', 'b', 'c'];

  for (const element of array1) {
    console.log(element);
  }
```

```java
1.for 循环		// 确定执行次数时使用
  
2.for-Each		// 遍历数组和集合
 
  for(元素类型t 元素变量x : 遍历对象obj) {
        引用了x的java语句
  }

  // 遍历一维数组
  int[] arr = {1,2,4,5,6}
  for (int element : arr) {
    sout(element)
  }

  // 遍历二维数组
  int[][] arr = {{1,2},{2,2},{4,5,6,7}};
  for(int[] row : arr) {
    for(int element : row) {
      sout(element)
    }
  }

3.Arrays.toString(arr)
  // 将一维数组转化为字符串形式输出
  int[] arr = {1,2,4,5,6}		// [1,2,3,4,5]
```

**判断一个数据是否为数组**

```JS
isArray()

Array.isArray(arr)					// 返回布尔值
```

**检测数组各个元素的值**

```Js 
every(callback(element[, index[, array]])[, thisArg])  // every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。
// 参数形式与forEach方法相似，都是回调函数和一个thisArg

// 检测数组中的所有元素是否都大于 10
function isBigEnough(element, index, array) {
  return element >= 10;
}
[12, 5, 8, 130, 44].every(isBigEnough);   // false
[12, 54, 18, 130, 44].every(isBigEnough); // true



some(callback(element[, index[, array]])[, thisArg])		// some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。
// 参数形式与forEach方法相似，都是回调函数和一个thisArg

function isBiggerThan10(element, index, array) {
  return element > 10;
}

[2, 5, 8, 1, 4].some(isBiggerThan10);  // false
[12, 5, 8, 1, 4].some(isBiggerThan10); // true
```

**判断数组是否存在某个值**

（查询首个满足某个条件的元素值）

```JS
includes(valueToFind[, fromIndex)		// 参数为要查询的元素 与 起始查询的位置，返回布尔值
[1, 2, 3].includes(2)					// true



some()		// some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。

var fruits = ['apple', 'banana', 'mango', 'guava'];

function checkAvailability(arr, val) {
  return arr.some(arrVal => val === arrVal);
}

checkAvailability(fruits, 'kela');   // false
checkAvailability(fruits, 'banana'); // true



find(callback[, thisArg])		//  方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。与forEach方法参数形式相同

// 用对象的属性查找数组里的对象
var inventory = [
    {name: 'apples', quantity: 2},
    {name: 'bananas', quantity: 0},
    {name: 'cherries', quantity: 5}
];

function findCherries(fruit) {
    return fruit.name === 'cherries';
}

console.log(inventory.find(findCherries)); // { name: 'cherries', quantity: 5 }
```

```java
1.Arrays.binarySearch(arr,value)		// index 返回索引 		！数组必须是已经按顺序排序好的
  int[] arr = {1,3,4,5,6}
	int index = Arrays.binarySearch(arr,3)  // 1
```

**过滤数组，组成新的数组**

```JS
filter(callback(element[, index[, array]])[, thisArg]) // 生产新的数组，不改变原数组，参数形式与forEach方法相同，主要对数组做过滤抽取操作

let arr = [1,'a',2,'b',3,'c',4,'d',5,'e']
let newArr = arr.filter(function(e,i,a){return typeof e === 'number'})	// [1,2,3,4,5]
```

**将可迭代对象或者类似数组转换为数组**

```JS
Array.from(arrayLike[, mapFn[, thisArg])	// ES6 方法 返回新数组
// arrayLike 需要转换的原对象，mapFn存在每个元素都会执行此函数，thisArg指针

String => Array
Array.from('foo');
// [ "f", "o", "o" ]

Set => Array
const set = new Set(['foo', 'bar', 'baz', 'foo']);
Array.from(set);
// [ "foo", "bar", "baz" ]

Map => Array
const mapper = new Map([['1', 'a'], ['2', 'b']]);
Array.from(mapper.values());
// ['a', 'b'];
Array.from(mapper.keys());
// ['1', '2'];

使用箭头函数
Array.from([1, 2, 3], x => x + x);
// [2, 4, 6]
```

**在 index 位置插入元素**

```JS 
fill(value[, start[, end]])			//	用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。
// 只能用来填充一个固定值
// value 为要填充的值，start为起始要填充的位置（包括此位置），默认值为0。end为结束位置（不包含此位置），默认值为 arr.length

let arr = [1,3,5,7]
arr.fill(6)										//		[6,6,6,6],默认从起始到结尾都替换
arr.fill(6,1,2)								//		[1,6,5,7], 替换一个值

```

**根据 元素的值 （满足条件）查询到元素所在的索引**

```JS
indexOf(value，startIndex)			//	返回该元素第一次出现的索引，可以设定起始查询位 ，返回索引，未查找到返回 -1
arr.indexOf(2) 	 				// 从头开始查找，第一个出现 值为 2 的元素的索引

lastIndexOf(value，startIndex)			// 	返回该元素最后一次出现的索引，可以设定起始查询位，逆向查询
arr.indexOf(5)					// 从末位（起始位）开始逆向查找，第一个出现 值为 5 的元素的索引

findIndex(callback[, thisArg])			// 返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。参数形式与 forEach 一样，
// 与 indexOf不同在与可以先对要查询的数据进行处理后再查询，indexOf适用已知知道要查询的值，而此方法适合查询某个首先满足条件的元素 的 索引

// 查找首个素数的索引
function isPrime(element, index, array) {
  var start = 2;
  while (start <= Math.sqrt(element)) {
    if (element % start++ < 1) {
      return false;
    }
  }
  return element > 1;
}

console.log([4, 6, 8, 12].findIndex(isPrime)); // -1, not found
console.log([4, 6, 7, 12].findIndex(isPrime)); // 2
```

**将二维数组排序**

```JS
entries()			// 返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对
// 将一个一维数组，转化为可迭代的二维数组，将数组的索引作为键名，数组元素作为键值，而每一个 iterator1.next().value 就是二维数组中的元素（即一维数组），iterator1.next().value[0] 为此数组元素的索引，iterator1.next().value[1] 为此数组元素的值，iterator1.next().done 为此数组元素是否遍历到底的标志，未到底 false ，到底为 true

const array1 = ['a', 'b', 'c'];
const iterator1 = array1.entries();

console.log(iterator1.next().value);
// expected output: Array [0, "a"]					// 打印的同时也执行了next()
console.log(iterator1.next().value);
// expected output: Array [1, "b"]
console.log(iterator1.next().value[1]);
// expected output: "c"
console.log(iterator1.next().done);						// false
console.log(iterator1.next().done);						// true

// 二维数组
let arr = [[1,2],[33,56,11],[13,34,9]];
let arrIter = arr.entries()

console.log(arrItem.next().value)					// [[0],[1,2]]
console.log(arrItem.next().value)					// [[1],[33,56,11]]
console.log(arrItem.next().value[1])			// [13,34,9]

// 二维数组的排序
let arr = [[1,34],[456,2,3,44,234],[4567,1,4,5,6],[34,78,23,1]];
SortArr(arr);

function entriesSortArr(arr) {
  let goNext = true;
  let entries = arr.entries();
  while (goNext) {
    let item = entries.next();
    if (item.done !== true) {
      item.value[1].sort((a,b) => a - b);
      goNext = true;
    } else {
      goNext = false;
    }
  }
  return arr
}

sort()
function SortArr2(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i].sort((a - b) => a - b)
  }
}
```

## Java [Arrays 工具类](http://c.biancheng.net/view/5885.html)

java.util.Arrays类能方便地操作数组，它提供的所有方法都是静态的。静态方法是属于类的，不是属于类的对象。所以可以直接使用类名加方法名进行调用。Arrays作为一个工具类，能很好的操作数组。

## [Java ArrayList](https://www.runoob.com/java/java-arraylist.html)

ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。

基本操作

```Java
import java.util.ArrayList; // 引入 ArrayList 类

1.创建对象
    ArrayList<E> objectName = new ArrayList()
  	// E: 泛型数据类型，用于设置 objectName 的数据类型，只能为引用数据类型。
  	ArrayList<String> arr = new ArrayList();
2.添加元素
  arr.add([指定要插入的位置,]"google")	//	默认插入最后一位
3.访问元素
  arr.get(1)	// 访问索引为 1 的数组元素
4.修改元素
  arr.set(2,"google")		// 第一个参数为索引位置，第二个为要修改的值
5.删除元素
  arr.remove(3)		 // 删除第四个元素
6.计算大小
  arr.size()
```

遍历

```java
1.for循环
  
  
2.for-Each
  for (String element : arr) {sout(element)}

3.forEach方法
  arr.forEach((e) -> {
    e = e + 10;
  })
```

排序

```java
判断两个字符是否
```

此类型的其他方法

```java
===
```



## Java HashMap

**基本操作**

```java
1.创建 HashMap 对象
  import java.util.HashMap; // 引入 HashMap 类
  HashMap<Integer, String> Sites = new HashMap<Integer, String>();
2.添加键值对
  Sites.put(1, "Google");
3.访问元素
  Sites.get(3);	// 参数为 index ，返回此位置的值
4.删除键值对
  Sites.remove(4); // 参数为 index ，删除此键对应的键值对
5.替换某键值对
  Site.replace(2, "newValue"); // 将 key为 2 的值 替换为 newValue
6.检测键 为 key 的键值对是否存在
  Site.containsKey(1);
7.检测值 为 value 的键值对是否存在
  Site.containsValue("Runoob");
5.清除所有键值对 
  Sites.clear();
6.计算大小
  Sites.size();
```

**迭代 HashMap**

可以使用 for-each 来迭代 HashMap 中的元素。如果你只想获取 key，可以使用 keySet() 方法，然后可以通过 get(key) 获取对应的 value，如果你只想获取 value，可以使用 values() 方法。

```java
正常
```

**其他方法**

与 ArrayLists 对象类似
