# 数组

## 基础概念

数组的定义：数 组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

JavaScript是动态语言，数组可以存储不同类型的数据，数组可以保存不同类型的值，这是因为其内部做了处理。对于 V8 引擎来说， 它将数据类型分为基本类型和引用类型，**基本类型直接存储值在栈上，而引用类型存储指针在栈上**，真正的内容存到堆上。因此不同的数据类型也可以保持同样的长度。

为什么静态语言要求存储同样类型的数据类型？为了支持随机访问，可以用**基址 + 偏移量**来定位任意一个元素

### 线性表

> 线性表：数据像排成一条线一样的结构，每个线性表上的数据只有前和后两个方向，除了数组，链表、栈、队列都是线性表结构
>
> 非线性表：二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

#### **连续的内存空间和相同类型的数据**

> 连续的内存空间和相同类型的数据，正是因为这个特点而对应出了 随机访问 的特性。同时也因为这个特点带来弊端，因为要保持连续性，不便于插入和删除
>
> **在进行随机访问时，由于是连续的内容空间，同时数据类型相同（每个数据大小也是相同的），那么在进行随机访问时，就非常方便，可以利用计算公式来访问`a[k]_address = base_address + (k-1)*type_size`**
>
> **所以数组这种结构，适用于数据已经确定好了，后续不用修改，仅用来快速查询的**

> **注意！！：**
>
> 我们常说  **数组适合查找，查找时间复杂度为 O(1)**，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表 述应该是，**数组支持随机访问，==根据下标随机访问==的时间复杂度为 O(1)。而哈希表查询是O(1)**

#### **关于数组插入操作的相关问题**

数组中插入是不方便的，但是我们需要仔细的来分析一下，假设在数组中插入数据，数组大小为 n ，数据在数组每个位置插入的概率都是相同的，最坏插入的时间复杂度为 O(n) （即最后一位），**平均复杂度为  (1+2+ …n)/n=O(n)**。所以数组中插入数据总体效果不是很好

如果我们只是把数组当做一个存储数据的集合，无序，那么在想要插入的位置插入数据，可以先将在这个位置的数据移动到最后一位，然后再将数据插入到这个位置，时间复杂度也为 O(1），这在快速排序中有使用到这个思想

如果非要在数组中删除一个元素话，那么也不能直接删除这个元素，只有将数组的最后一个元素的值覆盖掉要删除的元素，然后删除掉最后一个元素，从而实现删除的效果，无论什么语言，在数组这种结构中，使用内置方法直接删除某个元素都是会将数组的进行重新排序，性能不好，最好的方式就是数组仅仅用来查询值，而不进行修改

#### **关于数组删除操作的相关问题**

和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的 数据，则最坏情况时间复杂度为 O(n)；**平均情况时间复杂度也为 O(n)。**

实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们**将多次 删除操作 集中在一起执行**，删除的效率会提高很多，我们可以先记录下已经删除的数据。 每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。 **这也是JVM 标记清除垃圾回收算法的核心思想**

#### **数组编号为什么不从1开始而从0开始**

为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？

**从CPU执行指令的效率上来看**

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就 表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式：

`a[k]_address = base_address + k * type_size`

但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：

`a[k]_address = base_address + (k-1)*type_size`

对比两个公式，我们不难发现，从 1 开始编号，**每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令**。 数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号， 而不是从 1 开始。

**从历史原因来看**

C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都**效仿了 C 语言**，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了 从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。

> 二维数组访问的地址计算公式（假设二维数组的维度为m * n）：
>
> `a[i][j]_address = base_address + (i * n + j) * type_size`

## 题目推荐

- 28
- 75
- 380
- 59
- 859








