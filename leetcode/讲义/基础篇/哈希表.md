# 散列表（Hash Tab）

## 基础概念

**散列表用的是数组支持按照下标随机访问数据的特性，所以列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。**

- 哈希表查询的精髓就在于数组，哈希表查找的平均时间复杂度 $O(1)$ 就是因为这个。
- 哈希表新增和删除的精髓就在于链表或树，哈希表修改和删除的平均时间复杂度 $O(1)$ 就是因为这个。

**索引等于要查询的关键字，如果要查询的关键字不是正规的非负整数，而是字符串或者较大的数值，那么需要一个散列函数先对要查询的关键字进行映射处理，将其转化为数组下标，而通过散列函数处理后的值称为散列值（哈希值）**

散列函数设计是重点，通过设计一种合理的映射函数，可以最大化的使用到数组内存，同时不影响查找效率，而关键的一点也是 **如何把较大的数值或者字符串映射为一段较为连续的数组索引**，无论如何设计哈希函数，在一定的内存空间，总会发生不同的查询值通过哈希函数映射后为相同的数组索引，而这个称为哈希冲突

### 哈希冲突两种解决方法

1. 开放寻址法
2. 链表法

#### 开放寻址法

开放寻址法又分为线性探测和平方探测，基本的原理都是在发生哈希冲突时，查找下一个空闲位置，将值存储在空闲位置上，那么在查找的时候，先通过哈希函数映射找到了哈希冲突的位置，**对比要查询的值和哈希冲突位置存储的值**，发现不相等，那么就按照线性的方式依次对比值或者平方的方式跳跃式的对比值，如果对比到，即查找成功，如果遇到下一个空闲位置，说明这个值不存在于这个哈希表中

删除哈希表中的数据，不能将数据置空，会影响到开放寻址法寻找元素，产生误查，可以设置为delete证明此处是后来删除的，不是在创建的时候就为空

开放寻址法的线性探测存在缺点，当哈希表中存储的数据越来越多，哈希冲突也越来越大，空闲位会越来越少，那么在查询一个值的时候，线性探测的时间会越来越久，极端下是O(n)，所以可以改为二次探测（不为线性探测，依次+1，+4，+9）和双重散列（两个散列函数，第一个转换如果冲突，使用第二个散列函数，函数转换的哈希值再从数组空间上存储对应的哈希位置上）的开放寻址法

开放寻址法无论使用哪种探测方式，在散列表的空闲位置不多的时候，散列冲突概率就会大大提高，所以在使用这种方式时，需要预留一定的空闲位限制，保证这种数据结构的高效性，用装载因子来表示空位的多少

> 散列表的装载因子 = 填入表中的元素个数 / 散列表的长度
>
> 装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。
>
> **当数据量比较小、装载因子小的时候，适合采用开放寻址法**

#### 链表法

依旧使用一定内存数组空间（散列表），在发生哈希冲突的时候，使用的是哈希冲突位置附属的链表，将冲突的数据依次连接存储到链表中，当查找、删除一个元素的时候，通过散列函数计算出对应的哈希位置，然后遍历链表进行查找或者删除。查询的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。

> 也就是说链表在解决哈希冲突上更容易理解，但是在进行查询的时候，极端情况下如果通过映射都存储在一个链表中，那么查询的时间也会退化为O(n)
>
> 链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。而且，因为链表中的结点是零散分 布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定 的影响。 当然，如果我们存储的是大对象，也就是说要存储的对象的大小远远大于一个指针的大小 （4 个字节或者 8 个字节），那链表中指针的内存消耗在大对象面前就可以忽略了。
>
> 对链表法稍加改造，可以实现一个更加高效的散列表。那就是将链表法 中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突， 极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过 是 O(logn)。这样也就有效避免了前面讲到的散列碰撞攻击
>
> **基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列 表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。**

### 应用

单词输入，检验单词输入错误，提醒正确拼写，这个过程是如何高效的检索得知单词输入错误？，使用散列表，常用单词20万个，算平均每个单词10个字母，一个字母4字节，也就是20MB可以存储常用的单词，如何存储这些单词，并且高效的查询。使用散列表，也就是开辟一条20MB的数组空间，一个单词一个哈希位，查询时不会发生哈希冲突，所以时间复杂度为O(1)

> 在不发生哈希冲突的情况下散列表直接查询的时间复杂度 O(1)

散列表碰撞攻击的基本原理就是攻击者设计精良的数据，是所有数据都发送哈希冲突，从而使哈希表的查询效率下降为O(n)，当数据量十分大的时候，导致查询时间退化非常大，导致线程资源和CPU过分占用，系统无法响应

### 算法层面

**散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，（主要是他的查询操作是 O(1)，所以插入删除查询时间复杂度都为O(1)）**，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它**无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中， 然后排序，再遍历**。 因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散 列表中的数据的时候，都需要先排序，那效率势必会很低。**为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。**

> **链表这种数据结构最大的缺点就是 查询效率非常低为 O(n)，一般情况下结合 散列表来使用 （散列表的查询复杂度为 O(1)），两种数据结构结合使用在实际应用中非常常见**，比如说 LRU缓存淘汰算法
>
> 哈希表是一种在**平均时间复杂度** O(1) 内可实现**任何操作**的数据结构，这里的操作包括查询，插入，删除以及修改。需要注意的是这里描述的是平均时间复杂度，最坏的情况仍然有可能是线性的。
>
> **平均时间复杂度** 是否能达到 O(1) 和哈希算法以及冲突处理算法都有关， 也就是说需要你的哈希函数设计地足够好才能达到平均时间复杂度 O(1)

算法中常用的是哈希函数 有 **ASII码对比字符的映射关系**

## 哈希函数相关

### 如何设计哈希函数

**散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能。**

散列函数的设计不能太复杂。过于复杂的散列函数，势必会消耗很多计算时间，也就 间接的影响到散列表的性能。其次，散列函数生成的值要尽可能随机并且均匀分布，这样才 能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不 会出现某个槽内数据特别多的情况。

### **装载因子过大或者过小**

装载因子过大的话，表示散列表中存储的数据量过多，容易产生哈希冲突，那么时间复杂度就会下降。可以通过动态扩容的方法来解决这问题，当数据量的占比达到一定的阈值时，启动动态扩容机制，比如说存储内存空间翻一倍，但是同样带来的问题是 需要重新计算每个数据对应的散列表中的位置，均摊复杂度分析下为 O(1) ，也就是在 达到阈值时，复杂度为 O(n)

如果系统对内存空间比较敏感的话，那么装载因子过小的话也会可以动态缩减存储空间

> 在达到阈值时才进行数据量的计算和搬迁的话势必会带来时间上的延迟，所以在当达到阈值时将新存的数据直接存储到新的内存空间内，然后在慢慢的同时搬迁旧内存中的数据。发生查找问题时先在新内存中查找，再到旧内存中查找

## 哈希算法

哈希算法的定义和原理非常简单，**将任意长度的二进制值串映 射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值**

**要想设计一个优秀的哈希算法并不容易，数据结构算法层面上设计的哈希函数相对来说简单一点，重要的关注哈希冲突问题**

> 一个优秀的哈希算法的基本要求：
>
> 1. 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）； 
> 2. 对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同； 
> 3. 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小； 
> 4. 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。

哈希算法再实际中的应用问题（密码加密，数据校验等） ： 访问链接文件

## 常见题目类型

- **统计 xx 出现次数/频率/** 

该种题比较直观，若已知数据范围较小且比较连续，可以考虑用数组来实现。

[【每日一题】- 2020-04-27 - 多人运动](https://github.com/azl397985856/leetcode/issues/347)

题目推荐：

- [811.子域名访问计数](https://leetcode-cn.com/problems/subdomain-visit-count/description/)
- **需要查找/增加/删除操作为 O(1)时间复杂度** （一些设计题）

见到这种要求的题可以考虑一下是否需要 hash 表来做，比如 LRU，LFU 之类的题，题目中要求了时间复杂度，就是用 hash 表+双向链表解决的。

- **题目类型为图数据结构相关** （比如并查集）

这样可能需要构建有向图/无向图，这时可以用 hash 表来表示图并进行后续操作。

- **需要存储之前的状态以减少计算开销**（比如经典的两数和）

相信大家做过 dp 的一些题目就知道，记忆化搜索，该方法就利用 hash 表来存储历史状态，这样可以大大减少重复计算。

- 状态压缩（本质就是 bit 上的哈希结构）

## 模板（伪代码）

1. 判断目标值是否出现过（例题如：两数之和、是否存在重复元素、合法数独等等）

```
for num in nums:
    if num(该处为目标值target) in hashtable:
	return true
return false
```

1. 统计频率

数据比较离散

```
for num in nums:
    if num in hashtable:
	hashtable[num] += 1
    else
	hashtable[num] = 1
# 后续操作
-------------------
```

数据范围较小且连续则可以用数组代替

```
// 假设数据范围是0-n且n较小
int[] hashtable = new int[n + 1];

for num in nums:
    hashtable[num] += 1;

// 后续操作
------------------
```

## 题目推荐

- 218
- 500
- 36
- 37