# 字符串匹配

1. BF算法
2. RK算法
3. BM算法
4. KMP算法



单模式串匹配

多模式串匹配



主串：被查找的字符串，通常定义长度为 n

模式串：要在主串中的查找的与其相同的子串，通常定义长度为 m

> 我们在字符串 A 中查找字符串 B，那字符串 A 就是主串，字符串 B 就是模式串。 我们把主串的长度记作 n，模式串的长度记作 m。因为我们是在主串中查找模式串，所以 n>m。



## BF算法

Brute Force 暴力匹配算法，朴素匹配算法

> 这种算法的字符串匹配方式很“暴力”，当然也就会比较简单、好懂，但相应的性能也不高。

BF 算法的思想可以用一句话来概括，那就是，**我们在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串**，看有没有跟模式串匹配的

最坏情况下：以某个位置起始比较，每次都要比较到最后一个字符，那么对比 m 次，同时比较到主串的最后一个子串起始位，即 n-m+1 这个起始位对应的子串。那么其对应的时间复杂度为 O（(n-m+1) * m），简化为 O(n*m)

> 实际开发中这种算法其实用的也挺多，虽然计算得时间复杂度较高，但是在实际开发中通常主串和模式串都不会太长，而且每次在匹配的时候，当遇到不匹配的字符时就，停止了并不会对比m次，所以实际算法的执行效率比O(n*m)高，另外这种算法思想较为简单，不容易出现bug
>
> **所以在实际开发中，暴力匹配算法够用了**

```JavaScript
/**
 * @name bf
 * @param <String> s 主串
 * @param <String> m 匹配串
 * @return <Number> pos 返回匹配串在主串第一次出现的位置，若不存在，返回-1
 */
function bf(s = '', m = '') {
   const lenS = s.length
   const lenM = m.length
   // 首先将匹配串比主串长度还长及不符合题意的意外情况排除
   if(!lenS || !lenM || lenS < lenM) {
     return -1
   }
  // 注意一下边界条件
   for(let pos = 0; pos < lenS - lenM + 1; pos++) {
     let j = 0
     while(j < lenM && s[pos + j] === m[j]) {
       j++
     }
     // 匹配完成
     if(j === lenM) {
       return pos
     }
  }
  return -1
}
```

```java
int ViolentMatch(char* s, char* p)
{
	int sLen = strlen(s);
	int pLen = strlen(p);
 
	int i = 0;
	int j = 0;
	while (i < sLen && j < pLen)
	{
		if (s[i] == p[j])
		{
			//①如果当前字符匹配成功（即S[i] == P[j]），则i++，j++    
			i++;
			j++;
		}
		else
		{
			//②如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0    
			i = i - j + 1;
			j = 0;
		}
	}
	//匹配成功，返回模式串p在文本串s中的位置，否则返回-1
	if (j == pLen)
		return i - j;
	else
		return -1;
```

> 这种算法存在的问题就是， 当匹配不成功的时候，主串的的索引 i 回溯过多，导致效率降低，而KMP算法就是在这个基础上进行修改
>

## RK算法

Rabin-Karp 算法，是由它的两位发明者 Rabin 和 Karp 的名字来命名的。本质上是 BF 算法的升级版，使用到了哈希算法

仔细发现 BF 算法，在每次进行比较的时候，都需要依次的对比每个字符，这样导致算法效率比较低（也就是 O(n*m) 中的 m 部分就是由于每次都比较而由来的），那么RK算法就是针对这个问题进行优化，简化掉每次都要对比的这个过程

RK算法的思路：

我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配有匹配的概率（因为怕因为哈希冲突导致值一样而实际不匹配问题），进而再将这个有概率的子串来进行依次比较，由于在初始比较比较的是数字，所以比较非常快，O(1)，如果哈希冲突较少的话，那么整个算法的主要是分为两部分，一部分是 n-m+1 个子串的哈希表的构建 ，一部分是模式串的哈希值与 n-m+1 依次比较的过程。

1. n-m+1 子串个哈希值的计算，把每个子串的计算的时间看做为O(1)，那么 n-m+1个子串的时间复杂度是 O(n-m+1) 近似 O(n)
2. 模式串在与子串进行依次比较的时候，时间复杂度是 O(n-m+1) ，近似O(n)

那么由于在进行子串哈希值计算的循环中，就可以完成与模式串的哈希值比较，那么两者时间复杂度和起来就是 O(n）



复杂度分析完了，相对BF算法，RK算法效率确实提升不少



但是也存在几个关键点：

1. 哈希函数如何设计
2. 哈希冲突较多的情况下，那么冲突较多的时候，由于每次冲突仍然需要模式串与子串依次进行比较，那么算法的效率将会大大降低，甚至降低到 O(n*m），所以关键点在于哈希函数的设计



哈希函数的设计十分重要，前面提到 把 每个子串的计算的时间看做为O(1)，如果使用传统的方法，遍历子串中的每个字符，最后计算出这个子串的哈希值。显然是与 O(1)相违背的，遍历每个字符，O(m)，计算 n-m+1 个子串，O(n-m+1)， 那么完成整个子串的哈希表所用的 时间复杂度为 O(（n-m+1） * m ) ，在与比较时间复杂度合并 依旧是 O(n*m) ，算法整体的效率并没有提高，只是节约了每次比较的时间

我们可以发现每个 子串的计算哈希值是可以找到规律的，这也是 RK 算法的精髓所在，假设字符串中的额字符都是使用的字母 a-z ，那么我们以每个字母对应一个 数字，从 0 对应到 25 这 26 个数字，我们用 字符 映射 26进制下的值，0 表示 a , 1  表示 b ,依次 25 表示 z ，那么 假如 子串为 abc 那么其对应的 26进制的即为 0 * 26^2 + 1 * 26^1 + 2  * 26^0  ，为了便于比较值是否相等，我们将其转换为 10 进制下的对应值 ，那么  " abc " = 0 * 26 * 26 + 1 * 26 + 2 * 1 =   28 

 如果主串为 dbcedb , 模式串的长度为 3 ，那么

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200728003837913.png)

以上画横线的两个为相邻的两个子串对应的哈希值计算式，以 i 表示子串的起始点， h[ i ] 表示为 以这个起始点对应的子串 计算后的哈希值 ，s [ i ] 表示为 i 这个点的字符对应的哈希值，那么根据上图的总结出规律：

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200728004124384.png)

而像 26 进制比较大的数，也可以用一个哈希表提前将 0~m 个对应的计算值提前计算出来，需要时查询即可，（注意查询放置在哈希值的计算循环中 O(1)，不是另外查询造成 O（m）），这样可以提高计算时间

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200728004454515.png)

那么根据公式 ，只需要在第一次计算出 h[ 0 ] 对应的哈希值，然后后续子串带入前一个子串的哈希值即可计算出此子串的值，所以整个过程都是在一个循环中完成，时间复杂度为 O(n-m+1)

那么与比较的 O(n-m+1) 都可以在一个循环中同时完成 构建和比较 ，那么最终的时间复杂度为 O(n-m+1) 即 O( n )



关于 26 进制过大或者模式串长度过长而导致 最终计算的哈希值超过了 整数数据范围内的问题，可以进行多种方式的优化，比如不使用 26 进制，改为10进制，又或许在 26进制的基础上将最后计算出来的哈希值，统一除以一个较大的素数，来减小范围。又或者 不使用进制，直接用数字映射对应字母，将映射的数字直接相加，不做位数操作，来比较哈希值，这些都是关于哈希函数的设计，但是这样的结果会带来更大概率的哈希冲突，那么RK算法的效率将会降低，无论如何设计哈希函数，RK算法都是抓住哈希函数对各个子串计算哈希值存在规律这一特点来实现效率的突破。设计一个可以应对各种类型字符的哈希算法并不简单。

## BM算法

Boyer-Moore 算法 ，它的性能是著名的 KMP 算法的 3 到 4 倍，在最坏情况下的时间复杂度为 O(n)

> 这个算法相对来说较为复杂，其实在实际的工作中，几乎是不会使用到的，我们主要是学习其中的思路，拓展对算法的理解

 推荐文章：[KMP、BM和Sunday算法的详细介绍](https://blog.csdn.net/v_JULY_v/article/details/7041827)

文章中基本对BM算法的核心部分进行了讲解，接下来对 BM 算法进行梳理：



仔细对比 BF 算法 和 RK 算法，BF算法思路较为简单，依次对比每个子串，不合适继续下一个对比， RK算法是通过哈希函数对每个子串计算对应的哈希值，与模式串的哈希值进行比较来判断是否匹配，它们共有的特点就是每一个子串都会比较到，这就存在效率上的浪费，而 BM 算法就是针对这个地方进行优化，不必要的匹配直接不匹配

> **BM 算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率。**

比如说主串中某位上的字符在模式串中根本没有对应的字符，那么这个位置上以前的位置而构建的子串肯定是无法匹配到模式串的，因为在这个位置之前的子串，一定是会包含这个字符，那么模式串中一定是不会有字符与其对应，所以不可能会匹配成功，那么我们就可以直接将 将匹配的子串的起始点滑动到这个字符的后面，从而省略了前面不必要的匹配。

而 BM 算法的问题就在 如何确定最优的滑动距离又不会错失合适的匹配

为了解决这一问题，我们需要使用到两个规则：坏字符规则和好字符规则

> BM 算法与一般的匹配算法不同的地方还在于，在进行主串的子串和模式串进行对比的时候，BM 算法是从模式串的后面开始对比（也就是序列号从大到小对比，从 m-1 开始与对应的子串最后一位对比）

我们先来看坏字符规则：

我们进行对比工作，比如说最后一位匹配失败，那么我们将子串中的那位字符称作 坏字符 ，那么我们将这个 坏字符与模式串中的其他字符进行比较，查看是否有与其相同的字符，如果也没有，那么这个字符是没有的（同上述示例一样），新的对比子串的起始点，可以直接转移到这个坏字符的后面一位，如果这个坏字符在模式串中有与其相同的字符，那么可以将子串移动，使这两个字符相对应，接着同样的进行末位的字符对比，依次进行

那么我们如何衡量 子串的起始点的变化距离，准确的来说是如何 确定模式串滑动的距离

我们进行量化操作，当发生不匹配的时候，将坏字符对应的模式串中的字符的下标 记为 si ，如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi，如果不存在，那么我们我们把 xi 记作 -1，那模式串往后移动的位数就等于 si-xi。（不存在也是使用这个公式，也就是示例一样，直接滑动到坏字符的后面一位作为子串的起点，这就是设置其为 -1 的巧妙点，可以用过实例演示来找到规律，从而知道设置-1是合适的）

> 如果坏字符在模式串里多处出现，那我们在计算 xi 的时候，选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。

单独使用坏字符规则看似解决了这一问题，但是还是存在不足，比如说主串是 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。坏字符为a，xi = 3 , si = 0 ，那么 si - xi =  -3 , 还要往前滑动3位，显然是不符合的

我们接着看好字后缀规则：

好后缀规则思路大体与坏规则思路相似，但是存在区别，我们在分析坏字符规则的时候，忽略了一种情况，也就是从末位开始匹配的字符，如果连续几位都是匹配成功的，那么这些匹配成功的部分也是对滑动距离有优化价值的

假如说我们末位开始向上已经匹配成功了 2 位， 那么我们将子串中的这 2 位字符称为好后缀团，我们先在模式串中寻找是否有相同的字符团，如果有，那么我们就移动模式串，使好后缀团与模式串对应上，然后继续比较末位

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200729003137735.png)

如果没有 2 位相同的字符团，我们是否就直接将 模式串 移动到这好后缀团的后面的 ？这样是不行的，会错过合适的匹配，如：

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200729003612282.png)

那么我们要抓住特点，如果最大好后缀团没有找到相同的，那么 最大好后缀团中有 子集字符团正好与 模式串的头部相匹配，那么移动到相配的部分，就可以解决过度移动的问题，（比如图中的 c 正好与 模式串的头部相匹配，滑动过去来匹配 ）

> 针对这种情况，我们不仅要看 好后缀 在模式串中，是否有另一个匹配的子串，我们还要考察 好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的
>
> 后缀子串和前缀子串的意思：比如 c , bc ,称为 子串 abc 的后缀子串，而 a , ab ,称为 子串 abc 的前缀子串。

也就是 如果 好后缀团的后缀子串中有与 模式串的前缀子串相等的，那么就可以移动使他们匹配，当然好后缀团的后缀子串要从最大后缀子串选取开始对比

好后缀规则的移动距离量化规则与坏规则量化规则原理相似，好字符规则是选取 后缀子串的第一个字符对应 模式串的位置索引 设为 si ，将另外查找到相同的模式串的第一位的索引设置为 xi ,那么移动的距离也是 si - xi 



坏字符规则和好后缀规则的原理基本了解了，那么我们探究一个问题，在某位匹配失败后，我们可以通过坏字符规则，计算出滑动的距离，也可以通过好后缀规则来计算出滑动的距离,那么我是用哪个移动的距离呢？

我们会分别计算好 两种规则对应移动的距离，然后选取移动距离大的那一个，（因为两种规则本质没有问题，坏字符规则的缺点是会向前滑动，移动值为负值，而好后缀规则解决了这一问题，而单独使用好规则也有缺点，比如遇到第一个字符匹配失败，好字符无法使用规则，只能向后移动一位，类似于原始的BF算法，但是没有坏字符规则，也能够实现字符匹配）



原理分析完毕，我们来看 代码实现 （尽管实现代码相对于其他算法来说比较长，如何用代码或者技巧来实现原理）



先来看 坏字符 部分的实现，当遇到坏字符时，要计算往后移动的位数 si-xi，其中 xi 的 计算是重点，我们如何求得 xi 呢？或者说，如何查找坏字符在模式串中出现的位置呢？

如果我们拿坏字符，在模式串中**顺序遍历**查找，这样就会比较低效，势必影响这个算法的性能

针对查找问题我们可以直接联想到 散列表

我们可以将模式串中的每个字符及其下标都存到散列表中。这样就可以快速找到坏字符在模式串的位置下标了。这样在查询的时候，时间复杂度为 O(1) ，但是会因为另外创建散列表 而另外开辟内存空间

如何实现散列表呢，我们可以创建一个256长度的数组，来记录每个字符在模式串中出现的位置，数组的下标对应字符的 ASCII 码值，数组中存储这个字符在模式串中出现的位置（遇到相同的字符，那么其对应的数组下标是用一个（基于ASCII码而建立的索引），那么用后面出现的字符位置覆盖掉即可（避免多滑动））

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200730002710531.png)

实现代码：

变量 b 是模式串，m 是模式串 的长度，bc 表示刚刚讲的散列表。

```java
private static final int SIZE = 256; // 全局变量或成员变量
private void generateBC(char[] b, int m, int[] bc) {
    for (int i = 0; i < SIZE; ++i) {
        bc[i] = -1; // 初始化 bc
    }
    for (int i = 0; i < m; ++i) {
        int ascii = (int)b[i]; // 计算 b[i] 的 ASCII 值
        bc[ascii] = i;
    }
}
```

我们忽略 si-xi < 0 的情况下，只用 坏字符规则 来完成 BM 算法的设计，其对应的代码：（加上构建 散列表的代码）

```java
public int bm(char[] a, int n, char[] b, int m) {
    int[] bc = new int[SIZE]; // 记录模式串中每个字符最后出现的位置
    generateBC(b, m, bc); // 构建坏字符哈希表
    int i = 0; // i 表示主串与模式串对齐的第一个字符
    while (i <= n - m) {
        int j;
        for (j = m - 1; j >= 0; --j) { // 模式串从后往前匹配
            if (a[i+j] != b[j]) break; // 坏字符对应模式串中的下标是 j
        }
        if (j < 0) {
            return i; // 匹配成功，返回主串与模式串第一个匹配的字符的位置
        }
        // 这里等同于将模式串往后滑动 j-bc[(int)a[i+j]] 位
        // 如果存在另外相等的字符，散列表中存储了最靠相同字符的位置，那 j - 那个另外相同的字符的位置 也就是要移动的距离
        // 如果不存在另外相同的字符，那么里面存储的是 -1 ，所以直接移动 j+1 长度，也就是滑动到坏字符之后一位
        i = i + (j - bc[(int)a[i+j]]);
    }
    return -1;
}
```

实现图：

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200730003653781.png)

接着我们来查看 好后缀处理规则的 实现：

好后缀规则中有两个关键问题：

1. 在模式串中，查找跟好后缀匹配的另一个子串；
2. 在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串；

如果在要查询另外的跟好后缀匹配的另一个子串进行遍历暴力查询的话，这样效率显然是非常低效的，那么因为是查询问题，我们还是使用以内存来换取时间的方法，使用散列表。不过这个散列表较一般的不一样，是根据后缀子串的特点而专门设计的，在拿到模式串时，我们就将模式串为主体而建立一个数组，直接用模式串的 各个后缀子串 来表示索引显然是不可以的 ，我们通过映射关系 来变通一下，如图

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200730004802532.png)

用后缀子串的长度映射对应的后缀子串，这个映射关系是唯一的，非常合适，并且以 1 开始也非常适合做数组的索引，那么解决了 后缀子串表示问题，我们来看第一个关键问题，在模式串中，我们如何查找到和好后缀子串匹配的另一个子串 ? ，我们也是从 模式串 上开刀， 当我们拿到 模式串后，根据 各个后缀子串的字符内容，从后面开始遍历 模式串，如果找到了相同的 子串，那么就记录下 这个子串在模式串中的起始索引，然后停止遍历（因为我们只要存储最靠后的匹配字符），如果没找相同的匹配子串，那么我们就记录其为-1；我们把记录的这个数组称为 suffix 数组 ；效果如图：

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200730005402970.png)

我们很好的解决了 好后缀规则的 查找另外 匹配成功的子串的任务，但是第二个关键问题我们还没解决：在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串；

除了 suffix 数组之外，我们还需要另外一个 boolean 类型的 prefix 数组，来记录模式串的后缀子串是否能匹配模式串的前缀子串。也就是如果 好后缀子串 与 模式串前缀子串相等，他就可以移动过来做匹配，我们置其为 true，反之置为false，由于好后缀子串与模式串后缀是匹配对应的，所以我们也建立一个布尔型数组来存储 关系，，我们称这个数组为 prefix  数组。如图：

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200730010342113.png)

> 长度为 1 的 b , 与模式串的长度为1 的 前缀串 不相等 为false 。长度为 3 的后缀子串 与长度为 3 的 前缀串相同，设置其为 true

那么我们用什么方法获得这两个数组中的数据呢，也就是我们如何根据 模式串 来获取这些信息

设计过程十分巧妙：

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200730011219743.png)

实现代码：

```java
// b 表示模式串，m 表示长度，suffix，prefix 数组事先申请好了
private void generateGS(char[] b, int m, int[] suffix, boolean[] prefix) {
    for (int i = 0; i < m; ++i) { // 初始化
        suffix[i] = -1;
        prefix[i] = false;
    }
    for (int i = 0; i < m - 1; ++i) { // b[0, i]
        int j = i;
        int k = 0; // 公共后缀子串长度
        while (j >= 0 && b[j] == b[m-1-k]) { // 与 b[0, m-1] 求公共后缀子串
            --j;
            ++k;
            suffix[k] = j+1; //j+1 表示公共后缀子串在 b[0, i] 中的起始下标
        }
        i
            if (j == -1) prefix[k] = true; // 如果公共后缀子串也是模式串的前缀子串
    }
}
```

>  BM 算法 构建的规则有两类，坏字符规则和好后缀规则。好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，我们可以只用好后缀规则来实现 BM 算法。





未完成。。。（suffix、prefix数组的求导过程有点晦涩）



## KMP 算法

KMP 算法是根据三位作者（D.E.Knuth，J.H.Morris 和 V.R.Pratt）的名字来命名的，算法 的全称是 Knuth Morris Pratt 算法，简称为 KMP 算法。

KMP数组中最难懂的部分就是关于 next 数组的理解 以及如何求 next 数组，推荐先看 [如何更好地理解和掌握 KMP 算法?](https://www.zhihu.com/question/21923021)，先理解 next 数组怎么来的再去了解 KMP 算法效果要好的多，接下来我基于答主的文章进行简要的概括，并加入自己的理解进行梳理



先了解 PMT 这个概念 （部分匹配表(Partial Match Table)）

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200806234749234.png)

> 前后缀的概念 ： 前缀就是在此字符串的基础上，从第一个字符开始，依次向后增加一个字符组成一个字符串，但不包括最后一个字符而组成的字符串而组成的一个集合，这个集合称为此字符串的前缀集合（前缀集合属于字符串的子集，但不完全等于，只是其中的一部分）。而后缀同理，但从最后一个字符串开始增添字符而组成字符串，称为后缀

如图，index 是对应字符的索引，而 value 的值 就是 此字符位置截止而组成的字符串，这个字符串的前缀和后缀的公共字符串集合中最大长度 ，比如 ababa 这个位置截止的字符串，其前缀集为 { 'a','ab','aba','abab'} ,其后缀集 {'a','ba','aba','baba'} ,他们的最大公共字符串 为 ' aba ' ，长度为 3 ，所以这个位置的字符 对应的 value 值为 3  。总结来说 ：**PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度**

PMT 并不是 next 数组，但是 next 数组在 PMT 的基础上改进的 ，后面再讲解 为什么要改为 next 数组而不直接 使用 PMT 

我们来看看 在利用这个表来提升效率

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200806235837065.png)



但发生不匹配的时候，**我们需要移动 模式串，（其实在代码层上实现移动 就是 修改 j  的指针指向，因为始终是拿 s[i] ,m[j] 来比较，当改变完 j  的指向后，再进行比较时，其实已经完成了移动和对比操作）**

如图，当发生不匹配时，**KMP 算法的优化的地方就是 避免多余浪费的 回溯，所以 要以 最小程度的 移动 j 的位置** 。（在 BF 算法中的处理是，**将 i = i - j + 1 ，将 j = 0** 。也就是将 主串的起始位置后移一个，再与从头开始的模式串比较，**实际每次回溯的距离 一定是 i - j -1** （ j 的大小就是 i 主串和模式串在进行对比时 i 指针移动的距离，所以 i - j 就回到了 i 指针的起始位置），过于死板，效率低下, **并且主要以修改 i 指针为主，也就是 i 指针回溯** ），

那么我们 要利用到 PMT ，为什么可以利用到 PMT， 因为你仔细发现，**当 模式串的前缀 与 匹配失败位置之前的字符串（不包括本身匹配失败的字符）的后缀如果存在 相同，那么我们 就不用 移动  i - j -1 这么多位置，如果相同的部分 长度为 K ，那么我们只需要 移动 j-k 的距离 就可以完成最大效率的移动**，（因为在 模式串中 j  的位置发生匹配失败，而模式串的前 K 个字符 与 主串匹配失败前的字符串的 后 K 个字符相同，直接将 j 修改为 模式串的第 K + 1 位 ，即完成了 j-k 的移动操作），而这个相同部分 K 的值恰好与我们的 PMT 中的 value 值相对应，不过尴尬的是，当前匹配失败 的位置 j , 想要查询他前面字符串的前缀和后缀的公共部分的长度，得查询 PMT[j-1] ,（因为在设计 PMT 表的时候就是以包含自身的字符而组成的字符串，来查看最大公共字符串，这也是 next 数组的产生根本原因）

因为 在字符串中 是 以 0 为开头，而我们的 PMT 中的 value 是实际的 相同字符数 即 K ，所以 在修改 j  指针的位置时，直接使 j = k 即可（也就是 j = PMT），此时 j  就是模式串中指向 相同字符（前缀）的后面那一位

next 数组产生的原因：

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200807002523243.png)

所以解决了前面的那个尴尬问题，**直接访问 next[j] 的值也就是除了自身字符外前面字符串的 相同字符（前后缀最大公共字符串）的长度，当匹配失败时，将 j 指针指向 前后缀最大公共字符串的长度的值，完成了最优回溯 **

> **本算法的核心，理解 next[j] 到底指的什么，指的是 j 这个字符的前面的字符串（不包括本身字符）的前后缀最大公共字符串长度 （也就是 K 值）**

所以 KPM 算法的框架代码如下：

```java
int KMP(char * t, char * p) 
{
    int i = 0; 
    int j = 0;

    while (i < strlen(t) && j < strlen(p))
    {
        if (j == -1 || t[i] == p[j]) 
        {
            i++;
            j++;
        }
        else 
            j = next[j];
    }

    if (j == strlen(p))
        return i - j;
    else 
        return -1;
}
```

**else 语句中的 当 匹配失败 ，直接 令 j = next[j] 。也就是令 j 的值为匹配失败的位置的前面字符串的 前后缀最大公共字符串的长度，由于字符串的 以 0 为起始的影响，所以也正好指向相同部分的后面一位，然后继续进行比较**

最后的问题，如何求解 next 数组的 值

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200807003658627.png)

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200807004131008.png)

理解一下这个过程，求 next 数组，也就是是求每个位置前那部分字符串的前后缀最大公共子串的长度，理解上图，把上面一排当做主串，下面一排当做模式串，把模式串的前部分开始与主串的后部分来进行对比，i 的指向表示当前从 0 到 i 的这个长度的字符串就是现在要求最大的前后公共字符串的原型字符串， j  指针指向的位置 也就是 各个字符位对应的的 next 值 （在看上图的时候，其实可以忽略 指针 i  后面的那部分，以及忽略下面模式串中同等内容的部分的字符，可以更加清晰的理解到这是依次求各个 原始模式串的各个前缀对应的 next 值的过程）

不断的移动 i  的值，来表示来求各个 长度的字符串 的 next 值，并且存在一个特点，在求前后缀最大字符串子串的时候 ，已经求出长度为 5 的字符串的原始字符串的前后最大字符串的长度如果为 3 ，那么当下一个长度为 6 的原始字符串的前后缀最大字符串可以参照长度为 5 的原始字符串的前后最大字符串已经求出来的 next 值，如果下一个新添加的字符 （i++），正好也与其前缀 往后添加的一个字符相同（j++），那么长度为 6 的原始字符串的最大前后缀公共子串的长度就可以为 4 。如果不相同，那么说明新添加这个字符后，无法构成相同的部分，前面的全部归为0 ，因为字符串的后缀最后一个字符与前缀不相同，那么后缀不可能存在于与前缀相同的部分，（也就是 d -> e  的这个过程）

对应的求导过程代码：

```java
void getNext(char * p, int * next)
{
	next[0] = -1;
	int i = 0, j = -1;

	while (i < strlen(p))
	{
		if (j == -1 || p[i] == p[j])
		{
			++i;
			++j;
			next[i] = j; // 前面 有 ++j ,所以赋值相当于对比成功 ，在前面的基础上 + 1 。最大公共子串长度 
		}	
		else
			j = next[j];	// 如果对比失败，
	}
}
```

> 最难理解的部分也就是 当 对比失败的时候 j = next [j] 是什么意思 ？
>
> 因为前一个的最长串的下一个字符不与最后一个相等，需要找前一个的次长串，问题就变 成了求 0 到 next(j) 的最长串，如果下个字符与最后一个不等，继续求次长串，也就是下一 个next(j)，直到找到，或者完全没有 ( 图中 d  - > e 的部分也就是 完全没有的情况，当然也是在一次求次的时候就跳到了顶端)
>
> 也类似于 KMP 算法中的 j = next[j] 。**在求 next数组的时候，也是利用了 KMP 算法，而在 求 next 数组的 内部使用 next 数组，是利用动态规划的特点来边创建 next 数组，边使用 next 数组**

复杂度分析：

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200807010910934.png)

总结 KMP 算法

1. KMP 算法其实与 BM 算法本质差不多 ，想要移动最少的回溯距离来忽略无用的对比，而关键在于 我如何知道每次移动的距离是最优的，我们需要一个数组，来存储当模式串的每个字符位发生匹配失败时，我们应该移动的距离（也就是 j 应该指向的位置）。而这个数组产生的原因是什么？为什么可以求出每个字符位发生匹配失败的时候可以知道他的最优移动距离？这就与字符串本身的结构特点以及 字符串匹配的特点来 发现的规律 ，发生字符匹配失败的时候，那么说明失败位置前部分的字符串一定是匹配成功的，也就是相同的，如果说 模式串的前缀子串与 主串中匹配失败位前部分组成的字符串的后缀子串存在相同，那么是不是就可以直接移动距离来使他们相对应，那么进而转化为求 这个直接移动的距离问题。而这个直接移动的距离问题也就是与他们相同部分的字符串的长度有关，（用 j - k 的到的就是直接移动的距离，现在目的是求 k），那么又如何来求匹配失败字符前的字符串中 在主串中匹配失败位前部分组成的字符串的后缀子串 与 匹配失败位前的模式串的前缀子串的最大公共子串，由于匹配失败前都是匹配成功的，所以在主串中匹配失败位前部分组成的字符串的后缀子串 实际就是匹配失败位前的模式串的后缀子串，进而转化为求 匹配失败位前的模式串的前后缀最大公共子串，求出这个问题，也就完成了 这个数组的构建，供在匹配匹配失败的时候直接使用。
2. 也就是说核心部分是 在 拿到 模式串的时候，如何求出每个位置截止的字符串的 最大前后缀公共子串的长度
3.  [视频](https://www.bilibili.com/video/BV12J411m74v?from=search&seid=2259799775433890346) 链接中的up 主用的方法是 应对考试的 如何来求 next 数组 方法，但是并不知道 next 数组的缘由
4. BF 算法是 回溯主串指针，将模式串子串置 0 ，KMP算法永远不回溯主串指针，模式串指针看着 next 数组中对应的值回溯


