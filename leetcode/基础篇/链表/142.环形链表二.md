# 142 环形链表二

## 题目描述

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithm20210220173650.png)

## 方法一：哈希表

### 思路

（略）

### 复杂度分析

- 时间复杂度：
- 空间复杂度：

## 方法二：[双指针](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/141ti-de-kuo-zhan-ru-guo-lian-biao-you-huan-ru-he-/)

### 思路

关键点：

1. 利用公式来构建模型关系，最后因为快指针转了圈不重要，取n=1，发现了公式关系，慢指针在环形内未完成部分正好等于慢指针从起点到入环节点的距离

2. **刻意制造相撞**，将快指针模拟慢指针过来的路径，当两者发生碰撞的时候，正好即为入环节点！

3. 画图理解，特别注意到两指针之间的倍数关系

4. 利用两指针正好发生第一次碰撞时，构建等式关系

   此时快指针模拟慢指针的速度，从起点出发

   ![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200611133105231.png)

   m = s

### 复杂度分析

- 时间复杂度：
- 空间复杂度：

### 代码

*JavaScript*

```JS
var detectCycle = function (head) {
  let slowP = head, fastP = head // 都从头节点出发
  while (fastP) {                // 指向null就说明没有环，返回null
    if (fastP.next == null) return null // fastP.next为null也说明无环
    slowP = slowP.next           // 慢指针走一步
    fastP = fastP.next.next      // 快指针走两步
    if (slowP === fastP) {       // 首次相遇
      fastP = head               // 让快指针回到头节点
      while (true) {             // 开启循环，让快慢指针相遇
        if (slowP === fastP) {   // 相遇地点肯定在入环处
          return slowP
        }
        fastP = fastP.next       // 快慢指针都走一步
        slowP = slowP.next
      }
    }
  }
  return null // head就是null的情况
```

```JS
var detectCycle = function(head) {
    let fast=head,slow=head
    while(fast){
        if(fast == slow && fast != head){
            fast = head
            while(true){
                if(fast == slow)
                    return fast
                fast = fast.next
                slow = slow.next
            }
        }
        fast = fast.next.next
        slow = slow.next
    }   
    return false
};
```

