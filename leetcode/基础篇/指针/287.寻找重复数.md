# [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

## 题目描述

```
给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。

 

示例 1：

输入：nums = [1,3,4,2,2]
输出：2
示例 2：

输入：nums = [3,1,3,4,2]
输出：3
示例 3：

输入：nums = [1,1]
输出：1
示例 4：

输入：nums = [1,1,2]
输出：1
 

提示：

2 <= n <= 3 * 104
nums.length == n + 1
1 <= nums[i] <= n
nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次

进阶：

如何证明 nums 中至少存在一个重复的数字?
你可以在不修改数组 nums 的情况下解决这个问题吗？
你可以只用常量级 O(1) 的额外空间解决这个问题吗？
你可以设计一个时间复杂度小于 O(n2) 的解决方案吗？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-the-duplicate-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 方法一：暴力解法

### 思路

两遍循环

### 复杂度分析

- 时间复杂度：O(n^2^)
- 空间复杂度：O(1)

## 方法二：哈希解法

### 思路

重复。一旦涉及出现次数，可以使用哈希表**

### 复杂度分析

- 时间复杂度：O(n)

  建立哈希表的过程是 O(n)，判断元素是否存在是 O(1)

  > 仔细分析这个过程，**其实判断这个数是否存在 是 穿插在哈希表建立的过程中，并不是再另外遍历一遍来判断**，也就是在建表的时候，先用if语句判断这个数是否存在于表中，如果存在则直接返回这个数，如果不存在不进入这个if语句，执行建表操作，即将数据插入到表中

- 空间复杂度：O(n)

### 代码

*JavaScript*

```JS
var findDuplicate = function(nums) {
  let slowPointer = 0
  let fastPointer = 0
  while (true) {
    slowPointer = nums[slowPointer]
    fastPointer = nums[nums[fastPointer]]
    if (slowPointer == fastPointer) {
      let _slowPointer = 0
      while (nums[_slowPointer] !== nums[slowPointer]) {
        slowPointer = nums[slowPointer]
        _slowPointer = nums[_slowPointer]
      }
      return nums[_slowPointer]
    }
  }
};
```

### **总结**

### 快慢指针（判断链表是否有环）

由于题目的特性，因为 `Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)`,即数组的值全部排列下来**基本是**连着的，可能存在一个值有多个，那么相应的有些值就不存在，那么如果我们把这个数组内的值当做一个链表来看，数组的值表示链表下一个指向的索引，（类似于 数组的值等于链表中的next的值），而由于有些值不存在，有些值存在多个，那么一定会有地方连接不起，因为有些指向了相同一个地方，也就是会构成环。根据这一特性，我们需要找到构成环的那个节点索引值，也就是题目要求的重复的值

转化为链表指向下一个节点来理解的话，并且求环节点，那么又回到了类似于 142 环形链表 那题的龟兔赛跑快慢指针的解法

#### 总结

**相对来说这个问题很难抽象到链表指向，并且是快慢指针中的这个绕环追击问题**

具体解析可以查看  <a href='./链表'>142 环形链表二</a>