# [875. 爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas/)

## 题目描述

```
珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。

珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  

珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。

返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。

 

示例 1：

输入: piles = [3,6,7,11], H = 8
输出: 4
示例 2：

输入: piles = [30,11,23,4,20], H = 5
输出: 30
示例 3：

输入: piles = [30,11,23,4,20], H = 6
输出: 23

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/koko-eating-bananas
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 方法一：二分法（双指针）

### 思路

查找到最合适的速度，在一定的事件以最慢的速度吃完，也就是在一段速度区间上选择一个合适的速度，速度区间的起始点是1，区间的结束点可以是香蕉堆中最大堆的值，那么可以选择二分法来快速找到那个速度，初始速度为 （1+香蕉堆中最大堆值）/2， 以这个速度来计算吃完所需要的时间与题设给的最大时间进行对比，如果所需时间要大于给与的最大时间，那么需要提升速度，那么就将速度的起点定义为原来起点与终点的一半（二分法的特征），如果所需时间小于给与的时间，那么速度太快了，还可以选择更小的速度，同理将速度终点定义为原来的一半。那么找到速度的跳出条件是什么呢？ 速度的跳出条件是慢速度指针的值移动到比快指针的值要大，因为寻找的是最小的速度，所以返回此时的最小指针指向的值

注意在选择一堆吃后，就算吃完也不会继续吃另一堆，也就是说如果某堆存在 S 个香蕉，每小时能吃 a 个 ，那么吃完这堆至少需要 Math.ceil(S/a) 小时

### 复杂度分析

- 时间复杂度：O(NlogW)，其中 N是香蕉堆的数量，W 是最大的香蕉堆的大小。
- 空间复杂度：O(1)。

### 代码

*JavaScript*

```JS
var minEatingSpeed = function(piles, H) {
  if (piles.length >= H) {
      // 因为每个小时只能吃一堆，吃完不能换，所以堆数等于小时数时，最大的堆就是解；循环找出最大的那一堆
      return piles.reduce((a, b) => Math.max(a, b));
  }
  // 排序，实际上不需要，可以直接用piles.reduce((a, b) => Math.max(a, b)) 找出最大值就行
  piles.sort((a, b) => b - a);
  let speedMax = piles[0];
  let speedMin = 1;

  // 二分查找；
  while (speedMax > speedMin) {
      const k = Math.floor((speedMin + speedMax) /2);
      // 计算当前速度下需要消耗的时间；
      const hours = piles.reduce((total, pre) => total + Math.ceil(pre/k), 0);
      if (hours > H) {
        // [k + 1, speedmax]
        speedMin = k + 1;
      } else {
        // [speedMin, k]
        speedMax = k;
      }
      // console.log(speedMin, speedMax, k);
  }
  // 这里之所以取的是speedMin， 而不是K，是因为当speedMin = k + 1造成 speedMin === speedMax时，
  // 已经跳出了二分，所以这时K是不对的，那为什么speedMin 就对喃， 因为speedMax已经经过了验证
  return speedMin;
};
```

### **总结**

难度难在于把问题抽象化为一个双指针问题，这个地方要找到的就是那个合适的速度（即在吃完的状态下的最慢速度），那么如何找到这个最合适的速度，已知最慢速度和最快速度（也就是知道这个速度区间，类似于已经把它排序好了），可以使用二分法，一半一半的跳着找，计算总的时间对比，大了小了继续调整，知道那个合适的速度，返回

