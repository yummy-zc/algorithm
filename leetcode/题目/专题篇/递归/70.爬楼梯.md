# 70 爬楼梯

## 题目描述

![](https://cdn.jsdelivr.net/gh/yummy-zc/image-warehouse/images/algorithmimage-20200815233618038.png)

## 方法一：递归

### 思路

**分而自治思想,动态规划** 

这是一个考察斐波那契数列的题目，

`f(n) = f(n-1)  + f(n-2)`

> 我们用 f(x) 表示爬到第 x 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：
>
> f(x) = f(x - 1) + f(x - 2)
>
> 它意味着爬到第 x 级台阶的方案数是爬到第 x - 1 级台阶的方案数和爬到第 x - 2 级台阶的方案数的和。很好理解，因为每次只能爬 1 级或 2 级，所以 f(x) 只能从 f(x - 1) 和 f(x - 2) 转移过来，而这里要统计方案总数，我们就需要对这两项的贡献求和

### 复杂度分析

- 时间复杂度：
- 空间复杂度：

### 代码

*JavaScript*

```JS
var climbStairs = function(n) {
	if (n==0) return 0
	else if (n==1) return 1
	else if (n==2) return 2
    
    return climbStairs(n-1) + climbStairs(n-2) 
};
```

递归算法精简，但是容易超时

## 方法二：**迭代循环法**

### 思路

（略）

### 复杂度分析

- 时间复杂度：O(n)
- 空间复杂度：O(1) 

### 代码

*JavaScript*

```JS
var climbStairs = function(n) {
	let f = []
    f[0] = 0 
    f[1] = 1
    f[2] = 2
    for (let i = 3; i <= n; i++) {
		f[i] = f[i-1] + f[i-2]
    }
    return f[n]
};
```

### 总结

以上两种方法其实本质是一样的，都是根据 斐波那契等式 ，而呈现的 ，只不过递归算法内部嵌套太多，容易超出时间限制，而第一个算法的实现，用循环依次计算出每个子元素的值，依次相加，正向计算

像这种问题，如果初始遇到很懵逼，不要慌张，首先想到暴力法，暴力法无法实现，那么查看题设的规律，可以手写出初始几个测试值，然后查看初始几个值是否存在规律，一旦遇到 N 级的规模问题，一定会存在规律，分而治之思想就是将大问题化为小问题，我们应该以局部来推广全部

在发现规律后，如何实现也是一个重要的问题，类似于斐波那契数列这种规律函数，可以熟练的掌握 递归算法，递归算法内部写初始值，返回时进行数据更替