## [189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)

![image-20200810202644597](/Users/yummy/web开发/GitHub/algorithm/基础篇/数组/数组.assets/image-20200810202644597.png)

**暴力法**

![算法 3](/Users/yummy/web开发/文章笔记/typora-notes/Typora笔记/算法/LeetCode（Lucifer）/基础篇/数组.assets/算法 3-2966596.png)

```js
var rotate = function(nums, k) {
    let temp = null , cur 
    // 循环置换的次数
    for (let i = 0; i < k % nums.length; i++) {
        cur = nums[nums.length-1]
      	// 整体搬移一个单位
        for (let j = 0; j < nums.length; j++ ) {
          	[cur,nums[j]] = [nums[j],cur]
        }
    }
}
```

将数组遍历循环依次改变,注意到  k % nums.length ，对循环进行优化，因为每旋转一个周期又回到了原来的位置

暴力法中对数组这种结构进行了遍历，依次对每个元素位置进行了移动，插入删除等操作在不使用API情况下，都是这样操作，虽然效率不高，但是却是基础，要熟练掌握

复杂度：

- 时间复杂度：O（n^2）
- 空间复杂度：O（1）

**使用额外数组**

```JS
var rotate = function(nums, k) {
    const n = nums.length;
    const newArr = Array(n);
    for (let i = 0; i < n; ++i) {
        newArr[(i + k) % n] = nums[i];
    }
  	nums.splice(0,nums.length,...newArr)
};
```

构建一个新数组，存放数据，因为怕覆盖数据所以不能直接由前到后直接覆盖。再复制回原数组

### 总结

在数组中插入或者删除某个元素，都会移动后面元素，如暴力法所示，这就是数组不便于插入与删除的本质，时间复杂度消耗太高

数组在使用多个指针的情况下，通过指针的判断，将不符合的数据直接比较过，可以直接覆盖，但是在数据有用的情况下，不能用移动指针来覆盖，

**内置函数**

```JS
var rotate = function(nums, k) {
    nums.unshift(...nums.splice(nums.length - k))
};

var rotate = function(nums, k) {
    let n = k % nums.length;
    for (var i = 0; i < n; i++) {
        nums.unshift(nums.pop())
    }
};
```

## 