## 1381 [设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/) 

## （构造，数组模拟，哈希表）

![image-20200606094711782](/Users/yummy/web开发/GitHub/algorithm/基础篇/数组/数组.assets/image-20200606094711782.png)

**数组模拟**

```JavaScript
var CustomStack = function(maxSize) {
		this.stack = []
    this.maxSize = maxSize
};

CustomStack.prototype.push = function(x) {
	if (this.stack.length < this.maxSize) {
        this.stack.push(x)
    }
};

CustomStack.prototype.pop = function() {
	if (this.stack.length === 0)
        return -1
    return this.stack.pop()
};


CustomStack.prototype.increment = function(k, val) {
	const min = Math.min(k, this.stack.length)
    for (let i = 0 ;i < min; i++){
        this.stack[i] += val 
    }
};

```

解析：

1. 题目自动设计好了模板，即为一个构造函数，而方法是定义在其原型上
2. 题解是将数组构建一个栈，利用数组中的原型方法实现了栈的结构特点
3. 将数组定义为这个构造函数的一个属性，而还存在一个size属性用来存储规定的数组最大值
4. 最后K值的对比用 Math原生方法比较出来最下值效果非常好和简洁

***复杂度分析***

- **时间复杂度：push 和 pop 操作的时间复杂度为 $O(1)$（讲义有提到），而increment操作的时间复杂度为 $O(min(k, stack.length))$**
- **空间复杂度：$O(1)$**

**java解法**

```java
class CustomStack {
    // 在类里面声明变量
    int[] arr;
    int top;

    public CustomStack(int maxSize) {
        // 构造函数里初始化变量
        arr = new int[maxSize];
        top = -1;
    }

    public void push(int x) {
        if (top >= arr.length - 1) return;
        arr[++top] = x;
    }

    public int pop() {
        if (top <= -1) return -1;
        top--;
        return arr[top + 1];
    }

    public void increment(int k, int val) {
        int limit = Math.min(k, arr.length);
        for (int i = 0; i < limit; i++) {
            arr[i] += val;
        }
    }
}
```

### 总结

Java中没有数组中内置的方法 push 和 pop ，通常的方法就是使用 数组来模拟，然后使用一个 额外的指针来 辅助，指针指向的位置表示栈的顶部位置，（正是因为数组的大小是固定的，无法直接改变数组的大小）

**优化（空间来换时间）**

***分析原来的特点:***

1. 每当执行一次increment时，都会遍历到范围内的每一个元素，进行相加操作，重复几次执行此函数后，会产生相应的浪费，可以进行优化
2. 只要序列大的值有相加的操作，那么序列小的肯定有相加的操作，所以在每次进行increment函数时，只需要标记范围内最末位的那个值，不用遍历每一个值

***优化操作：***

1. 另外构建一个数组（或者哈希表），对应这原stack，初始化此数组全为0，专门用来存储标记执行increment函数的标记值（也就是每执行increment函数，将val值添加到对应的标记上，实际此时并没有将值加到原数组上，而是加在标记数组上，什么时候真正意义添加到数组上呢，是在进行pop操作的时候）
2. 在pop操作的时候，在进行输出前，查询标记表格将自身值和标记数组上的值相加输出返回即可（同时还会将对应的标记的值添加到其前一位标记表上，（因为需要把标记传递上去，因为前面的值都有添加这个值，只不过是将标记添加在后末位上））

***优化结果：***

***避免了重复使用循环函数，优化了时间复杂度，以空间来换取时间***

![9e63bf59b9f83c4407bf0ef6a7a58a14b9e63fe01bc91b9a56c189982439acdd-custom_stack](/Users/yummy/web开发/文章笔记/typora-notes/Typora笔记/算法/LeetCode（Lucifer）/基础篇/数组.assets/9e63bf59b9f83c4407bf0ef6a7a58a14b9e63fe01bc91b9a56c189982439acdd-custom_stack.png)

```JS
/**
 * @param {number} maxSize
 */
var CustomStack = function(maxSize) {
    this.stack = [];
    this.hashMap = {};
    this.limit = maxSize;
};

/**
 * @parms {number} key 
 * @parms {number} value
 * @return {void}
 */
CustomStack.prototype._setInc = function (key, value) {
    // 细节，使相同的key相加
    if (!(key in this.hashMap)) {
        this.hashMap[key] = 0;
    }
    this.hashMap[key] += value;
}

/**
 * @parms {number} key
 * @return {number}
 */
CustomStack.prototype._getInc = function (key) {
  	// 没有，也要返回 0 ,获得后相加
    return this.hashMap[key] || 0;
}

/**
 * @parms {number} key
 * @return {number}
 */
CustomStack.prototype._size = function () {
    return this.stack.length;
}

/**
 * @param {number} x
 * @return {void}
 */
CustomStack.prototype.push = function(x) {
    if (this._size() < this.limit) {
        this.stack.push(x);
    }
};

/**
 * @return {number}
 */
CustomStack.prototype.pop = function() {
    let index = this._size() - 1;
    let add = this._getInc(index);
	
  	let val = this.stack.pop();
  	if (val === undefined) {
      return -1;
    }
    let re = val + add;

  	const newTop = index - 1;
    this._setInc(newTop, add)
    this.hashMap[index] = 0;

    return re;
};

/**
 * @param {number} k
 * @param {number} val
 * @return {void}
 */
CustomStack.prototype.increment = function(k, val) {
    let size = this._size();
    k = k > size ? size - 1 : k - 1;
    this._setInc(k, val);
};
```

***复杂度分析***

时间复杂度：pop() 和 push() 操作都是 O(1) , increment()在优化后时间复杂度也为 O(1)；

空间复杂度：额外使用了一个哈希表 空间复杂度 O(n)

*典型的空间换时间*

### 总结

以空间换时间，额外使用哈希表来作为辅助，因为哈希表的查询复杂度很低，具体的解决方法可查看上述解析，本题需要注意到的是，无论是使用模拟数组还是这种方式，针对解题来说都是可以的，本质数据是不完全对等的，比如这种解法，在修改数据的值的时候本质数据没有改变，只是在输出pop的时候，将值改变，满足输出，这种在算法中非常常见。

哈希表辅助数组来操作非常常用，哈希表来存储数据，需要时查询数据，效率高花费一点空间

构造方法 _getInc ，_ setInc  都是存在细节